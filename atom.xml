<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>田野光的技术小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangyeming.github.com/"/>
  <updated>2019-11-19T07:30:24.597Z</updated>
  <id>http://wangyeming.github.com/</id>
  
  <author>
    <name>田野光</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kotlin下的Gson解析Json数据</title>
    <link href="http://wangyeming.github.com/2019/11/12/kotlin-gson/"/>
    <id>http://wangyeming.github.com/2019/11/12/kotlin-gson/</id>
    <published>2019-11-12T11:42:46.000Z</published>
    <updated>2019-11-19T07:30:24.597Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin作为Android的官方开发语言已经有一段时间了，在项目过程中总结了一些Kotlin下处理Json的经验，记录下来和大家分享。</p><a id="more"></a><h1 id="Kotlin的数据类"><a href="#Kotlin的数据类" class="headerlink" title="Kotlin的数据类"></a>Kotlin的数据类</h1><p>Kotlin中，有一种只保存数据的类，称作<a href="https://www.kotlincn.net/docs/reference/data-classes.html" target="_blank" rel="noopener">数据类</a>。关键字是class前加一个data。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure><p>一切看起来很美好，接触过Kotlin的同学肯定知道，普通类下的var变量或val常量，都会有恼人的初始化提示，尤其是类的成员变量(var)，如果不给予初始化赋值，那么就需要手动添加lateinit关键字，如果初始化null，那么类型就变成了xx?, 对于Bean类而言，这些都是累赘。Data类正好解决了我们的问题。但是Kotlin的Data类在搭配Gson使用时，真的那么美好吗？看下一个问题。</p><h1 id="Data-class的字段可否为空的问题"><a href="#Data-class的字段可否为空的问题" class="headerlink" title="Data class的字段可否为空的问题"></a>Data class的字段可否为空的问题</h1><p>首先我们来看一个例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String, </span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt;</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User(name='<span class="variable">$name</span>', age=<span class="variable">$age</span>, data=<span class="variable">$data</span>)"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到，name,age,data 我们都申明为非空，但是实际上，这样的申明是没有多大用处的，举个最简单的例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(Gson().fromJson("", User::class.java))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(name=&apos;null&apos;, age=0, data=null)</span><br></pre></td></tr></table></figure><p>显然，除了Int类型的age之外，其它两个变量全都是null，这样Kotlin赋予的空指针检查也就无法使用了。</p><p>那么一种方式是我们把字段申明为可空，也就是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String?, </span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt;?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这是一种思路，但很多时候我们希望能设置一个默认值，于是我们按照Java的写法，尝试字符串默认值为空；</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">""</span>, </span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt;?</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还是上面的例子，</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(Gson().fromJson("", User::class.java))</span><br></pre></td></tr></table></figure><p>结果输出的是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User(name=&apos;null&apos;, age=0, data=null)</span><br></pre></td></tr></table></figure><p>居然没有生效，name原本的默认空值也被覆盖为null了, 这个问题网上也讨论了很多，其实是Gson这个库的处理方式导致的，在Gson的fromJson方法中，最终会尝试通过反射的方式，获取对象的无参构造函数去创建对象。简单来说，我们这里的User类，实际上他的构造函数有两个，分别是：</p><p>User(age: Int, data: List<string>)<br>User(name: String, age: Int,data: List<string>)</string></string></p><p>而显然，并没有无参的构造函数，而Gson这里的反射构造对象，会绕过构造函数，只会在堆中去分配一个对象实例。</p><p>解决方式目前来看，就是如果需要默认值，那么所有参数都设置默认值：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> name: String = <span class="string">""</span>, </span><br><span class="line">    <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样User相当于有一个User()的无参构造函数了，这样我们的初始化配置也会生效。</p><p>具体可以参考这篇博客：<a href="https://extremej.itscoder.com/gson_kotlin_data_class/" target="_blank" rel="noopener">Gson 反序列化 Kotlin 数据类默认值失效</a></p><h1 id="Json序列化空字符串如何当做null处理？"><a href="#Json序列化空字符串如何当做null处理？" class="headerlink" title="Json序列化空字符串如何当做null处理？"></a>Json序列化空字符串如何当做null处理？</h1><p>某些时候我们在将对象转成Json String的过程中，需要特别处理某些空字符串。例如拼接到url后面的参数，如果字符串为空，就不拼到参数当中。例如:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Params</span></span>(</span><br><span class="line">    <span class="keyword">val</span> p1: String = <span class="string">""</span>, </span><br><span class="line">    <span class="keyword">val</span> p2: String = <span class="string">""</span>,</span><br><span class="line">    <span class="keyword">val</span> p3: String? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> params = Params(<span class="string">"p1"</span>, <span class="string">""</span>, <span class="literal">null</span>)</span><br><span class="line">println(Gson().toJson(params))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//预期</span><br><span class="line">&#123;&quot;p1&quot;:&quot;p1&quot;&#125;</span><br><span class="line">//实际</span><br><span class="line">&#123;&quot;p1&quot;:&quot;p1&quot;,&quot;p2&quot;:&quot;&quot;&#125;</span><br></pre></td></tr></table></figure><p>这里其实是可以通过自定义序列化的方式来解决的，也就是将空字符串当做null来处理：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyStringAsNullTypeAdapter</span>: <span class="type">JsonSerializer</span>&lt;<span class="type">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(src: <span class="type">String</span>?, typeOfSrc: <span class="type">Type</span>?, context: <span class="type">JsonSerializationContext</span>?)</span></span>: JsonElement &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (TextUtils.isEmpty(src)) &#123;</span><br><span class="line">            JsonNull.INSTANCE</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            JsonPrimitive(src.toString())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> paramsGson = GsonBuilder()</span><br><span class="line">            .registerTypeAdapter(String::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">EmptyStringAsNullTypeAdapter</span></span>())</span><br><span class="line">            .create()</span><br><span class="line">println(paramsGson.toJson(params))</span><br></pre></td></tr></table></figure><h1 id="如何统一过滤Array中的null元素"><a href="#如何统一过滤Array中的null元素" class="headerlink" title="如何统一过滤Array中的null元素?"></a>如何统一过滤Array中的null元素?</h1><p>数组里的null元素是一个很坑的事情，通常情况下，除非后台在数组中明确返回了null元素之外，是不太可能在数组中存在null的。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">data</span>: List&lt;String&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> str = <span class="string">"&#123;\"data\": [null, \"s1\"]&#125;"</span></span><br><span class="line">println(Gson().fromJson(str, User::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出 User(name='', age=0, data=[null, s1])</span></span><br></pre></td></tr></table></figure><p>显然，在每个数组的声明中都申明为可空想想就是件麻烦的事，而且读取的时候额外的元素判空也是很恶心的一件事。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(</span><br><span class="line">    <span class="keyword">val</span> data1: List&lt;String?&gt;? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> data2: List&lt;String?&gt;? = <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">val</span> data3: List&lt;String?&gt;? = <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>当然我们尽量希望后台不要传null在数组中，但有的时候无法避免这种情况，该怎么处理呢？针对这种反序列化的情况，我们需要自定义JsonDeserializer</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveNullListDeserializer</span>&lt;<span class="type">T</span>&gt; : <span class="type">JsonDeserializer</span>&lt;<span class="type">List&lt;T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(json: <span class="type">JsonElement</span>, typeOfT: <span class="type">Type</span>, context: <span class="type">JsonDeserializationContext</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">        <span class="comment">//替换 Gson().fromJson(json, typeOff)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着问题来了，我们来看一下下面这个做法，能否满足我们的需求吗？</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveNullListDeserializer</span>&lt;<span class="type">T</span>&gt; : <span class="type">JsonDeserializer</span>&lt;<span class="type">List&lt;T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(JsonParseException::class)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(json: <span class="type">JsonElement</span>, typeOfT: <span class="type">Type</span>, context: <span class="type">JsonDeserializationContext</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> jsonArray = JsonArray()</span><br><span class="line">        <span class="keyword">for</span> (jsonElement <span class="keyword">in</span> json.asJsonArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jsonElement.isJsonNull) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            jsonArray.add(jsonElement)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Gson().fromJson(jsonArray, typeOfT)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的做法是将当前JsonArray中的null元素移除，但其实这样做是不够的，举个例子大家就明白了</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>(</span><br><span class="line">    <span class="keyword">val</span> list1: List&lt;String&gt;,</span><br><span class="line">    <span class="keyword">val</span> b: B,</span><br><span class="line">    <span class="keyword">val</span> list2: List&lt;C&gt;</span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>(</span><br><span class="line">    <span class="keyword">val</span> values: List&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span></span>(</span><br><span class="line">    <span class="keyword">val</span> values: List&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> gson = GsonBuilder()</span><br><span class="line">        .registerTypeAdapter(List::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>, <span class="type">RemoveNullListDeserializer</span>&lt;<span class="type">Any</span>&gt;</span>())</span><br><span class="line">        .create()</span><br><span class="line"><span class="keyword">val</span> a = gson.fromGson(jsonStr, A::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br></pre></td></tr></table></figure><p>我们这里注册的反序列化的方法，实际上只针对A.list1、A.list2和A.b.values三个元素生效，而A.list2.values是没办法接管到的。原因在于C的values的反序列化在注册的时候被更高层的List<c>覆盖了。所以我这里的处理方式是：</c></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoveNullListDeserializer</span>&lt;<span class="type">T</span>&gt; : <span class="type">JsonDeserializer</span>&lt;<span class="type">List&lt;T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(JsonParseException::class)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(json: <span class="type">JsonElement</span>, typeOfT: <span class="type">Type</span>, context: <span class="type">JsonDeserializationContext</span>)</span></span>: List&lt;T&gt; &#123;</span><br><span class="line">        removeNullEleInArray(json)</span><br><span class="line">        <span class="keyword">return</span> Gson().fromJson(json, typeOfT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeNullEleInArray</span><span class="params">(json: <span class="type">JsonElement</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (json.isJsonArray) &#123;</span><br><span class="line">            <span class="keyword">val</span> jsonArray = json.asJsonArray</span><br><span class="line">            <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; jsonArray.size()) &#123;</span><br><span class="line">                <span class="keyword">val</span> ele = jsonArray.<span class="keyword">get</span>(i)</span><br><span class="line">                <span class="keyword">if</span> (ele.isJsonNull) &#123;</span><br><span class="line">                    jsonArray.remove(i)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                removeNullEleInArray(ele)</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (json.isJsonObject) &#123;</span><br><span class="line">            <span class="keyword">val</span> jsonObject = json.asJsonObject</span><br><span class="line">            jsonObject.entrySet()</span><br><span class="line">                .filter &#123;</span><br><span class="line">                    it.value.isJsonArray || it.value.isJsonObject</span><br><span class="line">                &#125;</span><br><span class="line">                .forEach &#123;</span><br><span class="line">                    removeNullEleInArray(it.value)</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Gson中，抽象类JsonElement一共有四种类型，分别是JsonObject, JsonArray, JsonPrimitive, JsonNull.<br>可能存在数组的地方只可能是JsonArray或JsonObject。这里用了简单的递归，在反序列化数据之前，手动遍历所有可能存在的List，删除null元素。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Kotlin的数据类为我们定义数据类型的类提供了便利的同时，搭配Gson使用的时候,因为Gson采用了反射的方法获取默认的无参构造函数创建对象，如果没有无参构造函数的话，则通过反射直接绕过了构造函数创建对象，所以如果想让默认值生效，则必须提供无参的构造函数。而提供无参的构造函数的本身其实在开发上增加了负担。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin作为Android的官方开发语言已经有一段时间了，在项目过程中总结了一些Kotlin下处理Json的经验，记录下来和大家分享。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://wangyeming.github.com/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>自动生成SDK 上传Maven仓库的版本号插件</title>
    <link href="http://wangyeming.github.com/2019/11/06/gradle-plugin-for-auto-version/"/>
    <id>http://wangyeming.github.com/2019/11/06/gradle-plugin-for-auto-version/</id>
    <published>2019-11-06T09:14:29.000Z</published>
    <updated>2019-11-08T08:35:54.075Z</updated>
    
    <content type="html"><![CDATA[<p>在Android开发中，通过maven仓库管理SDK的版本、上传、依赖是很常见的方式。而其中版本号的管理是很多人忽略的点。本篇以实现一个自动管理SDK上传maven版本号的gradle插件为目标，说一说其中的门道。</p><a id="more"></a><h1 id="通过Maven管理SDK包"><a href="#通过Maven管理SDK包" class="headerlink" title="通过Maven管理SDK包"></a>通过Maven管理SDK包</h1><h2 id="三类第三方库"><a href="#三类第三方库" class="headerlink" title="三类第三方库"></a>三类第三方库</h2><p>Android开发中，我们以『包』的形式引入第三方的库，大致可以分为三类：</p><ul><li>以C和C++为语言生成的动态连接库，也就是so文件</li><li>以Java为语言生成的归档文件，也就是Jar文件</li><li>Android独有的包含资源文件的Android模块包，也就是aar文件</li></ul><h2 id="Gradle支持对maven仓库包依赖"><a href="#Gradle支持对maven仓库包依赖" class="headerlink" title="Gradle支持对maven仓库包依赖"></a>Gradle支持对maven仓库包依赖</h2><p>通常除了直接导入包文件到项目中之外，Android官方提供的默认的依赖及编译工具Gradle，支持项目直接引入对Maven库中已有的资源包进行依赖。作为Android开发者而言，再熟悉不过了。例如依赖okhttp，我们可能只需要在模块的build.gradle文件中加入这么一行：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'com.squareup.okhttp3:okhttp:3.12.0'</span></span><br></pre></td></tr></table></figure><h2 id="maven插件上传SDK"><a href="#maven插件上传SDK" class="headerlink" title="maven插件上传SDK"></a>maven插件上传SDK</h2><p>对于SDK开发者而言，通常我们也是期望把自己的SDK上传到指定的maven仓库中，而客户端只需要简单的申明对SDK的某个版本的依赖，就可以了。通常情况下，我们会通过一个叫「maven」的gradle插件，来帮助我们上传SDK到maven仓库中。我们来简单回顾一下步骤：</p><p>首先是在模块的build.gralde下，申明引入『maven』插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'maven'</span></span><br></pre></td></tr></table></figure><p>假设我们的SDK包含Android的资源，也就是生成aar文件，那么我们申明如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">uploadArchives&#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenDeployer &#123;</span><br><span class="line">            repository(<span class="string">url:</span> release_repository_url) &#123;</span><br><span class="line">                authentication(<span class="string">userName:</span> <span class="string">"your user name"</span>, <span class="string">password:</span> <span class="string">"your password"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            snapshotRepository(<span class="string">url:</span> snapshot_repository_url) &#123;</span><br><span class="line">                authentication(<span class="string">userName:</span> <span class="string">"your user name"</span>, <span class="string">password:</span> <span class="string">"your password"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            pom.version = <span class="string">"版本名称"</span></span><br><span class="line">            pom.project &#123;</span><br><span class="line">                artifactId = <span class="string">"your artifactId"</span></span><br><span class="line">                groupId = <span class="string">"your group id"</span></span><br><span class="line">                packaging = <span class="string">'aar'</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前面说的okhttp为例，”com.squareup.okhttp3”就是groupId, “okhttp”是artifactId，版本号则是在pom.version处申明。</p><p>到这里，回顾完一个Android SDK基本的上传流程了。接下来我们来说下版本号的问题。</p><h1 id="SDK版本号"><a href="#SDK版本号" class="headerlink" title="SDK版本号"></a>SDK版本号</h1><h2 id="正式版和快照版"><a href="#正式版和快照版" class="headerlink" title="正式版和快照版"></a>正式版和快照版</h2><p>maven仓库通常分为snapshot快照仓库和release发布仓库，snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库则是用来保存稳定的发行版本。具体到名称，只需要在该模块的版本号后加上-SNAPSHOT即可(大写)。maven仓库的管理允许统一版本名的快照包重复更新，但是对于发布版本则不允许修改，必须升级版本号。</p><h2 id="A-B-C"><a href="#A-B-C" class="headerlink" title="A.B.C"></a>A.B.C</h2><p>对于SDK的管理者而言，一个规范合理的版本号控制流程是很重要的。通常业内的做法是A.B.C的做法，</p><p>A代表大版本号，大版本号的变动通常意味着非常大幅度的升级，甚至可以不保证向低版本兼容。例如著名的异步流编程API，ReactiveX，1.x版本和2.x版本有相当多的改变，1.x的某些写法在2.x版本中已经是不兼容了。这个大版本号很适合做SDK的大幅重构，重大基础库的迁移等，例如从Android Support库转而采用Android-X库。</p><p>B代表中版本号，也是我们日常发版升级对应的版本号，例如1.0.0 -&gt; 1.1.0类似如此的升级。</p><p>C代表的是小版本号，目的是在版本之间，处理因为bug修复等情况的临时版本，例如1.0.0版本发布后，发现了一个重要bug，这是可以发布1.0.1这样的版本来修复问题。</p><h2 id="版本号管理的烦恼"><a href="#版本号管理的烦恼" class="headerlink" title="版本号管理的烦恼"></a>版本号管理的烦恼</h2><p>那我们说，版本号的烦恼在哪里呢？根据我自己的日常开发经验，可能有这么几处：</p><ul><li><p>缺少版本上传的历史记录，这一点可以说是很多SDK的痛点了，回顾某个很久之前发布的版本，忘记打tag，还原不了当时的代码情况。某个成员意外的执行上传任务，覆盖掉了原本的包，引入了包含bug甚至是编译不过的代码。</p></li><li><p>版本号的唯一性，在开发中我们通常会先集成快照包来开发和提测，在上线前某个时刻替换成正式版本。而快照包的依赖存在一些问题，例如，Android Studio的gradle缓存问题，有时候明明已经上传最新的快照包，但是IDE就是不更新。每次手动修改版本号，且不说麻烦，还没办法对应的上git提交记录。</p></li></ul><p>那么有什么好办法处理这些问题呢？</p><h1 id="自动管理版本号的Gradle插件"><a href="#自动管理版本号的Gradle插件" class="headerlink" title="自动管理版本号的Gradle插件"></a>自动管理版本号的Gradle插件</h1><p>我这里的处理方式是自己写一个简单的gradle插件，用来自动管理SDK上传Maven仓库时的版本号。</p><h2 id="插件功能的设计"><a href="#插件功能的设计" class="headerlink" title="插件功能的设计"></a>插件功能的设计</h2><p>首先我们希望每次上传新包到Maven仓库，能够记录一下上传记录，包括：上传人，上传时间，上传的版本号, 当前的分支名，最后一次提交的commit messgae等等</p><p>其次，版本名上我们希望附带两个功能，一个是指定是否为快照包，自动的在版本号后面加上-SNAPSHOT。一个是可以选择在版本号后面跟上唯一性的id。</p><h2 id="Gradle插件的开发"><a href="#Gradle插件的开发" class="headerlink" title="Gradle插件的开发"></a>Gradle插件的开发</h2><h3 id="Gradle插件开发"><a href="#Gradle插件开发" class="headerlink" title="Gradle插件开发"></a>Gradle插件开发</h3><p>首先是如何开发Gradle插件，这里我推荐这篇文章<a href="https://www.jianshu.com/p/3191c3955194" target="_blank" rel="noopener">Gradle插件开发指南</a><br>。这里我们开发一个独立的gradle插件项目，并上传到maven仓库中。</p><h3 id="新建Gradle插件工程"><a href="#新建Gradle插件工程" class="headerlink" title="新建Gradle插件工程"></a>新建Gradle插件工程</h3><p>Gradle插件的开发建议选择Intellij IEAD, 通过创建Gradle项目即可，语言我这里指定Groovy, 其实Java或者Kotlin甚至是Scala都是可以的。</p><p><img src="/img/2019-11-06-gradle-plugin-for-auto-version-01.png" alt></p><p>接着设置好gradle项目需要的GroupId, ArtifactId和Version信息，创建好工程。此时工程目录结构：</p><p><img src="/img/2019-11-06-gradle-plugin-for-auto-version-02.png" alt></p><p>其中groovy目录用来存放groovy代码，java目录存放java代码，resources目录用来声明当前项目所需的资源，后面我们介绍。其中的build.gradle文件看起来是这样：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">'groovy'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">group <span class="string">'xxx.xxxx'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">'org.codehaus.groovy:groovy-all:2.3.11'</span></span><br><span class="line">    testCompile <span class="string">group:</span> <span class="string">'junit'</span>, <span class="string">name:</span> <span class="string">'junit'</span>, <span class="string">version:</span> <span class="string">'4.12'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想用Android Studio来创建Gradle工程的话，可能会麻烦一些，在一个Android工程中，选择新建 Java Library module “plugin”，然后手动删除掉不需要的目录和文件，手动新建resources目录。</p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>首先是Gradle插件开发的模版套路，实现Plugin<project>接口，其中需要实现apply方法</project></p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoVersionPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着在resources文件夹下新建目录及文件：META-INF/gradle-plugins/auto_version_plugin.properties</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xxx对应着AutoVersionPlugin的完整包名</span></span><br><span class="line">implementation-<span class="class"><span class="keyword">class</span>=<span class="title">xxx</span>.<span class="title">AutoVersionPlugin</span></span></span><br></pre></td></tr></table></figure><p>到这一步，Gradle的壳就搭建起来了，接下来我们需要写业务逻辑：</p><p>第一步我们需要捕获maven插件的uploadArchives的task, 这里需要注意到的一点是uploadArchives属于工程的自定义task，而自定义task需要在工程的after evaluate执行完之后才能拿的到:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">project.afterEvaluate &#123;</span><br><span class="line">    <span class="comment">//Only after evaluate, we can find custom tasks</span></span><br><span class="line">    Task uploadTask = it.tasks.findByPath(<span class="string">"$&#123;it.path&#125;:uploadArchives"</span>)</span><br><span class="line">    uploadTask.doFirst &#123;</span><br><span class="line">        <span class="comment">//在uploadArchives Task执行之前做一些事</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好的，有了这一步的基础，我们接下来尝试定义gradle插件中可以用的DSL。首先我们定义DSL字段：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoVersion</span> &#123;</span></span><br><span class="line">    String version = <span class="string">''</span></span><br><span class="line">    String fixVersion = <span class="string">''</span></span><br><span class="line">    <span class="keyword">boolean</span> isSnapShot = <span class="literal">true</span></span><br><span class="line">    String gitPath = <span class="string">''</span></span><br><span class="line">    <span class="keyword">boolean</span> needFileLog = <span class="literal">false</span></span><br><span class="line">    String logFilePath</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应着实际调用就类似于：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">autoVersion &#123;</span><br><span class="line">    version <span class="string">'1.0.0'</span></span><br><span class="line">    fixVersion <span class="string">'1.1.0-SNAPSHOT'</span></span><br><span class="line">    isSnapShot <span class="literal">true</span></span><br><span class="line">    needFileLog <span class="literal">true</span></span><br><span class="line">    logFilePath rootProject.projectDir.absolutePath + File.separator + <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们只需要，在Plugin的apply方法中创建对应的DSL即可：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoVersionPlugin</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; &#123;</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">void</span> apply(Project project) &#123;</span><br><span class="line">        AutoVersion autoVersion = project.getExtensions().create(<span class="string">"autoVersion"</span>, AutoVersion.<span class="keyword">class</span>)</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们的准备工作ok了，接下来我们需要处理两个问题，如何修改uploadArchives中的版本号参数，以及如何获取当前工程git信息。</p><p>首先是处理uploadArchives，这个借助gradle的api就可以处理</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Task uploadTask强转为Upload即可</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">def</span> changeUploadTaskVersion(Upload uploadTask, String version) &#123;</span><br><span class="line">        <span class="keyword">def</span> deployer = uploadTask.repositories.getByName(<span class="string">"mavenDeployer"</span>) <span class="keyword">as</span> DefaultGroovyMavenDeployer</span><br><span class="line">        deployer.pom.version = version</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次是Git信息的获取，这里我们引入第三方库来帮助我们处理：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">'org.eclipse.jgit:org.eclipse.jgit:5.4.0.201906121030-r'</span></span><br></pre></td></tr></table></figure><p>这里我封装了GitInfo类，通过传入Git的路径，可以自动获取当前用户名，分支名，commit提交id和log记录等信息。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitInfo</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Git mGit</span><br><span class="line">    <span class="keyword">private</span> Repository mRepository</span><br><span class="line"></span><br><span class="line">    GitInfo(String gitPath) &#123;</span><br><span class="line">        String path = <span class="string">"$&#123;gitPath&#125;$&#123;File.separator&#125;.git"</span></span><br><span class="line">        File repoDir = <span class="keyword">new</span> File(path)</span><br><span class="line">        <span class="keyword">if</span> (!repoDir.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">'no git info'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        FileRepositoryBuilder builder = <span class="keyword">new</span> FileRepositoryBuilder()</span><br><span class="line">        mRepository = builder.setGitDir(repoDir)</span><br><span class="line">                .readEnvironment() <span class="comment">// scan environment GIT_* variables</span></span><br><span class="line">                .findGitDir() <span class="comment">// scan up the file system tree</span></span><br><span class="line">                .build()</span><br><span class="line">        mGit = <span class="keyword">new</span> Git(mRepository)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String name() &#123;</span><br><span class="line">        Config config = mRepository.getConfig()</span><br><span class="line">        <span class="keyword">return</span> config.getString(<span class="string">"user"</span>, <span class="literal">null</span>, <span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String branch() &#123;</span><br><span class="line">        <span class="keyword">return</span> mRepository.branch</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String commitId() &#123;</span><br><span class="line">        Iterable&lt;RevCommit&gt; logs = mGit.log().call()</span><br><span class="line">        Iterator&lt;RevCommit&gt; iterator = logs.iterator()</span><br><span class="line">        <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"no_commit_id"</span></span><br><span class="line">        &#125;</span><br><span class="line">        RevCommit revCommit = iterator.next()</span><br><span class="line">        <span class="keyword">if</span> (revCommit == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"no_commit_id"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> revCommit.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String shortCommitId() &#123;</span><br><span class="line">        Iterable&lt;RevCommit&gt; logs = mGit.log().call()</span><br><span class="line">        Iterator&lt;RevCommit&gt; iterator = logs.iterator()</span><br><span class="line">        <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"no_commit_id"</span></span><br><span class="line">        &#125;</span><br><span class="line">        RevCommit revCommit = iterator.next()</span><br><span class="line">        <span class="keyword">if</span> (revCommit == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"no_commit_id"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> revCommit.name.substring(<span class="number">0</span>, <span class="number">7</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String lastLog() &#123;</span><br><span class="line">        Iterable&lt;RevCommit&gt; logs = mGit.log().call()</span><br><span class="line">        Iterator&lt;RevCommit&gt; iterator = logs.iterator()</span><br><span class="line">        <span class="keyword">if</span> (!iterator.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"message"</span></span><br><span class="line">        &#125;</span><br><span class="line">        RevCommit revCommit = iterator.next()</span><br><span class="line">        <span class="keyword">if</span> (revCommit == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"message"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> revCommit.shortMessage</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的部分例如如何写文件，逻辑判断等这里就不多说了。</p><h2 id="上传插件及使用"><a href="#上传插件及使用" class="headerlink" title="上传插件及使用"></a>上传插件及使用</h2><p>上传方式之前就介绍过了，使用起来也很简单,在Android工程的根目录的build.gradle中，首先引入我们上传的插件：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'$&#123;your group id&#125;:auto-version:$&#123;your version&#125;'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次找到需要上传的模块所在的build.gradle文件，假设这里已经引入了maven插件并配置了uploadArchives task,<br>我们引入我们的auto-version plugin</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'auto_version_plugin'</span></span><br><span class="line"></span><br><span class="line">autoVersion &#123;</span><br><span class="line">    version <span class="string">'1.0.0'</span></span><br><span class="line">    fixVersion <span class="string">'1.1.0-SNAPSHOT'</span></span><br><span class="line">    isSnapShot <span class="literal">true</span></span><br><span class="line">    needFileLog <span class="literal">true</span></span><br><span class="line">    logFilePath rootProject.projectDir.absolutePath + File.separator + <span class="string">'xxx'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，上传maven任务和此前就一样，执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle uploadArchives</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本篇介绍了如何开发一个独立的gradle插件，来协助管理maven发布的版本号和记录发布信息。不足之处，多多包涵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Android开发中，通过maven仓库管理SDK的版本、上传、依赖是很常见的方式。而其中版本号的管理是很多人忽略的点。本篇以实现一个自动管理SDK上传maven版本号的gradle插件为目标，说一说其中的门道。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
      <category term="Gradle" scheme="http://wangyeming.github.com/tags/Gradle/"/>
    
      <category term="Maven" scheme="http://wangyeming.github.com/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Android的消息机制</title>
    <link href="http://wangyeming.github.com/2019/04/08/android-handler/"/>
    <id>http://wangyeming.github.com/2019/04/08/android-handler/</id>
    <published>2019-04-08T03:09:20.000Z</published>
    <updated>2019-09-09T12:30:06.614Z</updated>
    
    <content type="html"><![CDATA[<p>三年前我写过一篇Android的消息机制的<a href="https://www.jianshu.com/p/0e372a9bd3b3" target="_blank" rel="noopener">文章</a>，时隔三年，重新再讲Handler，希望有新的理解和收获。</p><a id="more"></a><h1 id="Android线程的通信"><a href="#Android线程的通信" class="headerlink" title="Android线程的通信"></a>Android线程的通信</h1><h2 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程"></a>何为线程</h2><p>Android的消息机制，是也就是Handler机制，是Android上进行线程间通信的最重要的框架。既然说到线程间通信，那么线程是什么呢？</p><p>教科书上说，进程是资源分配的最小单位，线程是CPU调度的最小单位。不过更好的说法是，进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p><p>知乎上某位答主的回答很好，我就大段引用一下:</p><p>CPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。</p><p><strong>一个最最基础的事实</strong>：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。</p><p><strong>一个必须知道的事实</strong>：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p><p><strong>串联起来的事实</strong>：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。</p><p>进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。<br>进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文</p><p>线程是什么呢？进程的颗粒度太大，每次都要有上下文的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。</p><p>以上引用自<a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">线程和进程的区别是什么？ - zhonyong的回答 - 知乎</a></p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><ul><li>初始(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li><li>运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。<br>线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li>阻塞(BLOCKED)：表示线程阻塞于锁。</li><li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>终止(TERMINATED)：表示该线程已经执行完毕。</li></ul><p>后面关于消息队列，就涉及到线程的阻塞状态。</p><p>我曾经写过一篇关于如何打印出java线程的六种状态的文章，可以参考：</p><p><a href="/2016/08/22/java-thread-state">java 打印线程的六种状态</a></p><h2 id="线程通信的方式"><a href="#线程通信的方式" class="headerlink" title="线程通信的方式"></a>线程通信的方式</h2><ul><li><p>Handler机制，这即是Android上进行线程间通信的最重要的方法，也是我们今天要讲的重点。</p></li><li><p>Broadcast广播，广播机制可用于进程/线程间通信</p></li><li><p>共享内存,例如单例，类成员变量等</p></li><li><p>文件/数据库</p></li><li><p>传统的java技术，例如java.io包的管道(Pipes)，Object的信号量(Signalling), 阻塞队列(BlockingQueue)等</p></li></ul><p>这一篇博文讲的很详细：</p><p><a href="https://www.oreilly.com/library/view/efficient-android-threading/9781449364120/ch04.html" target="_blank" rel="noopener">Chapter 4. Thread Communication</a></p><h1 id="Handler消息机制"><a href="#Handler消息机制" class="headerlink" title="Handler消息机制"></a>Handler消息机制</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Android系统中将通信的消息封装成<strong>Message</strong>对象,并且配备有专门的<strong>Handler</strong>去做事件的处理。而<strong>Message</strong>存放在一个叫<strong>MessageQueue</strong>的消息队列当中被分发处理的，而保证消息队列中消息不断被分发出去，正是<strong>Looper</strong>对象所做的事。</p><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><h3 id="线程中如何启用Looper"><a href="#线程中如何启用Looper" class="headerlink" title="线程中如何启用Looper"></a>线程中如何启用Looper</h3><p>正如我们概述中最后说的，是<strong>Looper</strong>所做的事。我们先直观的看Looper在线程中是如何启用的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LooperThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将当前线程初始化为Looper线程 </span></span><br><span class="line">        Looper.prepare();</span><br><span class="line">        <span class="comment">// ...其他处理，如实例化handler</span></span><br><span class="line">        <span class="comment">// 开始循环处理消息队列 </span></span><br><span class="line">        Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，那Looper本身到底是什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Looper</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * API Implementation Note:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This class contains the code required to set up and manage an event loop</span></span><br><span class="line"><span class="comment">     * based on MessageQueue.  APIs that affect the state of the queue should be</span></span><br><span class="line"><span class="comment">     * defined on MessageQueue or Handler rather than on Looper itself.  For example,</span></span><br><span class="line"><span class="comment">     * idle handlers and sync barriers are defined on the queue whereas preparing the</span></span><br><span class="line"><span class="comment">     * thread, looping, and quitting are defined on the looper.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Looper"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sThreadLocal.get() will return null unless you've called prepare().</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到Looper本身持有线程本身，持有消息队列，还持有线程局部变量<strong>ThreadLocal</strong>，并且通过线程局部变量持有Looper对象本身。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>穿插简单讲一下<strong>ThreadLocal</strong>是什么？</p><p><strong>ThreadLocal</strong>也就是线程局部变量，为每一个使用该变量的线程都提供一个变量值的副本，是Java中一种较为特殊的线程绑定机制，每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。</p><p>从线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。</p><p>通过ThreadLocal存取的数据，总是与当前线程相关，也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出现的并发访问问题提供了一种隔离机制。</p><p>ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。</p><p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p><p>更多内容可以参考：<a href="https://blog.51cto.com/lavasoft/51926" target="_blank" rel="noopener">深入研究java.lang.ThreadLocal类</a></p><h3 id="Looper-prepare"><a href="#Looper-prepare" class="headerlink" title="Looper.prepare()"></a>Looper.prepare()</h3><p>回到Looper上来，我们来看一下Looper的prepare()方法到底做了什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Initialize the current thread as a looper.</span></span><br><span class="line"><span class="comment">  * This gives you a chance to create handlers that then reference</span></span><br><span class="line"><span class="comment">  * this looper, before actually starting the loop. Be sure to call</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #quit()&#125;.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来很简单哈，也就是创建了Looper对象，并通过线程局部变量存了下来。</p><h3 id="Looper-loop"><a href="#Looper-loop" class="headerlink" title="Looper.loop()"></a>Looper.loop()</h3><p>前面的介绍我们知道Looper的loop()方法会启动消息队列的循环，来进行消息的实际分发，我们来看一下looper里面具体做的事：</p><p>代码很长，我们拆分成两部分看，先看外壳：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//clearCallingIdentity这个可以看成是安全性代码，也可以看成是调试代码作用是确定当前这个looper所在的“进程”</span></span><br><span class="line">    <span class="comment">//是否一直在同一个“进程”里，如果进程变多半是说明这个线程运行在某种跨进程代码里。</span></span><br><span class="line">    <span class="comment">//比如说你通过AIDL调用stub，远程那边接到之后启动一个线程，就有可能触发ident != newIdent了</span></span><br><span class="line">    <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">    <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">    <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">            SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                    + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                    + Thread.currentThread().getName()</span><br><span class="line">                    + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>准备工作没什么可说的，我们直接看for循环里面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">    <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">    <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">    <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">    <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">    <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">        slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">        Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">            Trace.traceEnd(traceTag);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">        <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                    msg)) &#123;</span><br><span class="line">                <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">        showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">        logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">    <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msg.recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码很长，我们看几个关键点，首先是从消息队列中读取下一个消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message msg = queue.next(); <span class="comment">// might block</span></span><br></pre></td></tr></table></figure><p>这里因为<strong>MessageQueue</strong>本身是个堵塞队列，所以这里可能会阻塞住，next()方法里面具体怎么执行的，待会说。<br>接着就是log和trace操作没什么可说的，下一个关键点是消息的分发：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//target就是Handler，可以看到这里通过调用Handler去分发消息事件</span></span><br><span class="line">msg.target.dispatchMessage(msg);</span><br></pre></td></tr></table></figure><p>最后就是回收<strong>Message</strong>资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg.recycleUnchecked();</span><br></pre></td></tr></table></figure><p>其实可以看到，整个loop()方法里面，核心的代码其实可以简化为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p>看完<strong>Looper</strong>的代码，我们顺着留下来的MessageQueue.next()方法，来看消息队列的实现。</p><h3 id="MessageQueue初始化"><a href="#MessageQueue初始化" class="headerlink" title="MessageQueue初始化"></a>MessageQueue初始化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MessageQueue"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// True if the message queue can be quit.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br><span class="line"></span><br><span class="line">    Message mMessages;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br><span class="line">    <span class="keyword">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br><span class="line">    <span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mQuitting;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Indicates whether next() is blocked waiting in pollOnce() with a non-zero timeout.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mBlocked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The next barrier token.</span></span><br><span class="line">    <span class="comment">// Barriers are indicated by messages with a null target whose arg1 field carries the token.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mNextBarrierToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br><span class="line"></span><br><span class="line">    MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">        mQuitAllowed = quitAllowed;</span><br><span class="line">        mPtr = nativeInit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<strong>MessageQueue</strong>里面有相当多的native代码，其实Android的消息机制中，除了Java层的handler机制外，还包括native的AHandler机制。对应着Java层的Looper和Message，就有对应的ALooper和AMessage.</p><p>其中nativeInit()方法对应的native方法实现如下，创建了NativeMessageQueue,并将这个对象的指针赋给了Java层的mPtr。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MessageQueue读取下一条消息"><a href="#MessageQueue读取下一条消息" class="headerlink" title="MessageQueue读取下一条消息"></a>MessageQueue读取下一条消息</h3><p>来看next()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Return here if the message loop has already quit and been disposed.</span></span><br><span class="line">    <span class="comment">// This can happen if the application tries to restart a looper after quit</span></span><br><span class="line">    <span class="comment">// which is not supported.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// -1 only during first iteration</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// Try to retrieve the next message.  Return if found.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Stalled by a barrier.  Find the next asynchronous message in the queue.</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Got a message.</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No more messages.</span></span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process the quit message now that all pending messages have been handled.</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If first time idle, then get the number of idlers to run.</span></span><br><span class="line">            <span class="comment">// Idle handles only run if the queue is empty or if the first message</span></span><br><span class="line">            <span class="comment">// in the queue (possibly a barrier) is due to be handled in the future.</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No idle handlers to run.  Loop and wait some more.</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Run the idle handlers.</span></span><br><span class="line">        <span class="comment">// We only ever reach this code block during the first iteration.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// release the reference to the handler</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset the idle handler count to 0 so we do not run them again.</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// While calling an idle handler, a new message could have been delivered</span></span><br><span class="line">        <span class="comment">// so go back and look again for a pending message without waiting.</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不出意外，这里的方法也很长，同样的，我们分析下核心的代码执行了些什么操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nativePollOnce(ptr, nextPollTimeoutMillis);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> NativeMessageQueue::pollOnce(JNIEnv* env, jobject pollObj, <span class="keyword">int</span> timeoutMillis) &#123;</span><br><span class="line">    mPollEnv = env;</span><br><span class="line">    mPollObj = pollObj;</span><br><span class="line">    mLooper-&gt;pollOnce(timeoutMillis);</span><br><span class="line">    mPollObj = <span class="literal">NULL</span>;</span><br><span class="line">    mPollEnv = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mExceptionObj) &#123;</span><br><span class="line">        env-&gt;Throw(mExceptionObj);</span><br><span class="line">        env-&gt;DeleteLocalRef(mExceptionObj);</span><br><span class="line">        mExceptionObj = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pollOnce()最终都是通过 Linux 的 epoll 模型来实现的。pollOnce() 通过等待被激活，然后从消息队列中获取消息。对应的也有一个wake()方法，则是激活处于等待状态的消息队列，通知它有消息到达了。这就是典型的生产者-消费者模型.</p><p>接着往下看，nativePollOnce()之后的大段逻辑就是如何分发Message，这里就不多说了。</p><h3 id="MessageQueue插入消息"><a href="#MessageQueue插入消息" class="headerlink" title="MessageQueue插入消息"></a>MessageQueue插入消息</h3><p>对应的方法是enqueueMessage(Message msg, long when)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">            <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">            <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">            needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的核心代码nativeWake(mPtr)前面也提到过了，和nativePollOnce(ptr, nextPollTimeoutMillis)一样，都是基于Linux 的 epoll 模型来实现的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Android中Natvie层消息机制，这篇文章我认为讲的不错：</p><p><a href="https://www.cnblogs.com/kesalin/p/android_messagequeue.html" target="_blank" rel="noopener">Android多线程分析之四：MessageQueue的实现</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>首先我们了解了线程，进程的基本概念，Java线程的六种状态，Android中线程间通信的几种基础方式等。随后我们结合了源码，着重介绍了Android中Handler的运行机制，在分析源码的过程中，我们发现了Android系统中，除了Java层的消息机制外，Natvie层也有一层消息机制，并且内部是通过Linux的epoll模型来实现的。而消息队列不断读取消息的本质，就是线程的阻塞。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;三年前我写过一篇Android的消息机制的&lt;a href=&quot;https://www.jianshu.com/p/0e372a9bd3b3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章&lt;/a&gt;，时隔三年，重新再讲Handler，希望有新的理解和收获。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>React Native in Android的项目实战03--基于ReactRootView封装RN Fragment</title>
    <link href="http://wangyeming.github.com/2019/03/14/react-natvie-for-android-03/"/>
    <id>http://wangyeming.github.com/2019/03/14/react-natvie-for-android-03/</id>
    <published>2019-03-14T10:59:23.000Z</published>
    <updated>2019-09-09T12:30:06.614Z</updated>
    
    <content type="html"><![CDATA[<p>ReactNative提供了ReactRootView，提供了集成RN View的途径。那么我们来看一下，如何通过ReactRootView，来封装项目中可以使用的Fragment。</p><a id="more"></a><h1 id="深入ReactRootView源码"><a href="#深入ReactRootView源码" class="headerlink" title="深入ReactRootView源码"></a>深入ReactRootView源码</h1><p>首先来看下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactRootView</span> <span class="keyword">extends</span> <span class="title">SizeMonitoringFrameLayout</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RootView</span>, <span class="title">MeasureSpecProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SizeMonitoringFrameLayout类就是FrameLayout的再封装,对外提供了一个onSizeChange的监听方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SizeMonitoringFrameLayout</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSizeChangedListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">int</span> oldWidth, <span class="keyword">int</span> oldHeight)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="meta">@Nullable</span> OnSizeChangedListener mOnSizeChangedListener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...省略构造函数</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnSizeChangedListener</span><span class="params">(OnSizeChangedListener onSizeChangedListener)</span> </span>&#123;</span><br><span class="line">    mOnSizeChangedListener = onSizeChangedListener;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mOnSizeChangedListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mOnSizeChangedListener.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再回来看ReactRootView内部，提供了startReactApplication()方法, 需要我们传入ReactInstanceManager和模块名等参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReactApplication</span><span class="params">(ReactInstanceManager reactInstanceManager, String moduleName)</span> </span>&#123;</span><br><span class="line">  startReactApplication(reactInstanceManager, moduleName, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReactApplication</span><span class="params">(ReactInstanceManager reactInstanceManager, String moduleName, @Nullable Bundle initialProperties)</span> </span>&#123;</span><br><span class="line">  startReactApplication(reactInstanceManager, moduleName, initialProperties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startReactApplication</span><span class="params">(ReactInstanceManager reactInstanceManager, String moduleName, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  @Nullable Bundle initialProperties, @Nullable String initialUITemplate)</span> </span>&#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, <span class="string">"startReactApplication"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line">    Assertions.assertCondition(</span><br><span class="line">      mReactInstanceManager == <span class="keyword">null</span>,</span><br><span class="line">      <span class="string">"This root view has already been attached to a catalyst instance manager"</span>);</span><br><span class="line"></span><br><span class="line">    mReactInstanceManager = reactInstanceManager;</span><br><span class="line">    mJSModuleName = moduleName;</span><br><span class="line">    mAppProperties = initialProperties;</span><br><span class="line">    mInitialUITemplate = initialUITemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mReactInstanceManager.hasStartedCreatingInitialContext()) &#123;</span><br><span class="line">      mReactInstanceManager.createReactContextInBackground();</span><br><span class="line">    &#125;</span><br><span class="line">    attachToReactInstanceManager();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>startReactApplication内部主要是做了两件事，一件是在后台去创建React<br>Context,另一个是attachToReactInstanceManager()，那么另一个是attachToReactInstanceManager()做了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachToReactInstanceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, <span class="string">"attachToReactInstanceManager"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (mIsAttachedToInstance) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mIsAttachedToInstance = <span class="keyword">true</span>;</span><br><span class="line">      Assertions.assertNotNull(mReactInstanceManager).attachRootView(<span class="keyword">this</span>);</span><br><span class="line">      getViewTreeObserver().addOnGlobalLayoutListener(getCustomGlobalLayoutListener());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactInstanceManager.attachRootView(ReactRootView)又做了什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ReactRootView&gt; mAttachedRootViews = Collections.synchronizedSet(</span><br><span class="line">    <span class="keyword">new</span> HashSet&lt;ReactRootView&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ThreadConfined</span>(UI)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachRootView</span><span class="params">(ReactRootView rootView)</span> </span>&#123;</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line">    mAttachedRootViews.add(rootView);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset view content as it's going to be populated by the application content from JS.</span></span><br><span class="line">    rootView.removeAllViews();</span><br><span class="line">    rootView.setId(View.NO_ID);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If react context is being created in the background, JS application will be started</span></span><br><span class="line">    <span class="comment">// automatically when creation completes, as root view is part of the attached root view list.</span></span><br><span class="line">    ReactContext currentContext = getCurrentReactContext();</span><br><span class="line">    <span class="keyword">if</span> (mCreateReactContextThread == <span class="keyword">null</span> &amp;&amp; currentContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      attachRootViewToInstance(rootView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ReactInstanceManager内部维护了一个Set<reactrootview>,所有attach到ReactInstanceManager的ReactRootView都会被记录下来。</reactrootview></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachRootViewToInstance</span><span class="params">(<span class="keyword">final</span> ReactRootView rootView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...省略无关紧要的代码</span></span><br><span class="line">    rootView.runApplication();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    UiThreadUtil.runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        rootView.onAttachedToReactInstance();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>ReactRootView的runApplication()方法我们就不再深入了，可以看一下它的注释说明</p><p>   Calls into JS to start the React application. Can be called multiple times with the same rootTag, which will re-render the application from the root.</p><p>可以看到，目的就是调到JS那里去启动React application。</p><p>而onAttachedToReactInstance()方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAttachedToReactInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create the touch dispatcher here instead of having it always available, to make sure</span></span><br><span class="line">    <span class="comment">// that all touch events are only passed to JS after React/JS side is ready to consume</span></span><br><span class="line">    <span class="comment">// them. Otherwise, these events might break the states expected by JS.</span></span><br><span class="line">    <span class="comment">// Note that this callback was invoked from within the UI thread.</span></span><br><span class="line">    mJSTouchDispatcher = <span class="keyword">new</span> JSTouchDispatcher(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (mRootViewEventListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mRootViewEventListener.onAttachedToReactInstance(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，目的就是将原生的View绑定上Js的Touch事件分发。至此，我们重新梳理下ReactRootView的逻辑，可以明确以下几点：</p><ol><li>ReactRootView继承自Android上FrameLayout,对外提供onSizeChange的接口。</li><li>ReactRootView提供了startReactApplication方法，用于在后台去创建React<br>Context以及绑定ReactRootView到ReactApplication上。</li><li>绑定ReactRootView到ReactApplication上这一步做了两件事，一个是启动React application，一个是启用JSTouchDispatcher，用于View的JS事件分发。</li></ol><h1 id="封装ReactRootView"><a href="#封装ReactRootView" class="headerlink" title="封装ReactRootView"></a>封装ReactRootView</h1><p>为了封装出我们需要的ReactNatvieFragment,我们需要对ReactRootView本身做一些封装，以实现怎么几个目的：</p><ol><li>外部不需要处理ReactInstanceManager的逻辑</li><li>通过Bundle或者其他参数的形式，传入url，通知JS具体加载哪个页面</li></ol><p>假设我们封装的一层View叫做RNBaseRootView，那么RNBaseRootView的构造函数可以是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RNBaseRootView</span><span class="params">(Context context, String <span class="keyword">module</span>, Bundle bundle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        <span class="keyword">this</span>.mModule = <span class="keyword">module</span>;</span><br><span class="line">        <span class="keyword">this</span>.mBundle = bundle;</span><br><span class="line">        initial();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了抽离RNBaseRootView和ReactInstanceManager的逻辑,我们把ReactInstanceManager的相关处理逻辑委托给RNApiManager类，例如初始化ReactInstanceManage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialReactInstanceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()</span><br><span class="line">            .setApplication(mRnDependency.getApplication())</span><br><span class="line">            .addPackage(<span class="keyword">new</span> MainReactPackage())</span><br><span class="line">            .addPackage(<span class="keyword">new</span> CommonReactPackage())</span><br><span class="line">            .addPackage(<span class="keyword">new</span> CustomComponentPackage())</span><br><span class="line">            .setJSBundleFile(mRnDependency.isRNDebug() ? <span class="string">""</span> : mRnDependency.bundlePath())</span><br><span class="line">            .setUseDeveloperSupport(mRnDependency.isRNDebug())</span><br><span class="line">            .setInitialLifecycleState(LifecycleState.BEFORE_RESUME);</span><br><span class="line">    <span class="keyword">if</span> (mRnDependency.isRNDebug()) &#123;</span><br><span class="line">        builder.setJSMainModulePath(<span class="string">"index"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mRnDependency.isRNDebug()) &#123;</span><br><span class="line">        mBundlePath = mReactInstanceManager.getDevSupportManager().getJSBundleURLForRemoteDebugging();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mBundlePath = mRnDependency.bundlePath();</span><br><span class="line">    &#125;</span><br><span class="line">    mReactInstanceManager.createReactContextInBackground();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似的，释放React Natvie的资源也可以放在里面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">destroyReact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mReactInstanceManager.destroy();</span><br><span class="line">        mReactInstanceManager = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FrescoModule.hasBeenInitialized()) &#123;</span><br><span class="line">        Fresco.getImagePipeline().clearMemoryCaches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，在NBaseRootView的初始化方法里面，我们可以通过调用RNApiManager类，完成我们的初始化操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    RNApiManager.getInstance().initialReact(<span class="keyword">new</span> OnInitialCompleteListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitialSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (initialed)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                mReactInstanceManager = RNApiManager.getInstance().getReactInstanceManager();</span><br><span class="line">                initialed = <span class="keyword">true</span>;</span><br><span class="line">                vReactRootView.startReactApplication(mReactInstanceManager, mModule, mBundle);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (vReactRootView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sendPageSize(vReactRootView.getMeasuredWidth(), vReactRootView.getMeasuredHeight());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInitialFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，ReactNativeFragment的实现就水到渠成了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReactNativeFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RNBaseRootView vRNBaseRootView;</span><br><span class="line">    <span class="keyword">private</span> String mModule;</span><br><span class="line">    <span class="keyword">private</span> Bundle mBundle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RNBaseRootView <span class="title">createRootView</span><span class="params">(Context context, String <span class="keyword">module</span>, Bundle bundle)</span> </span>&#123;</span><br><span class="line">        vRNBaseRootView = <span class="keyword">new</span> RNBaseRootView(context, <span class="keyword">module</span>, bundle);</span><br><span class="line">        <span class="keyword">return</span> vRNBaseRootView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vRNBaseRootView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            vRNBaseRootView = createRootView(getActivity(), mModule, mBundle);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vRNBaseRootView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以在工程中顺利的使用我们自己封装的ReactNativeFragment，可以很容易的嵌入到Tab中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ReactNative提供了ReactRootView，提供了集成RN View的途径。那么我们来看一下，如何通过ReactRootView，来封装项目中可以使用的Fragment。&lt;/p&gt;
    
    </summary>
    
      <category term="React Native in Android的项目实战" scheme="http://wangyeming.github.com/categories/React-Native-in-Android%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
      <category term="React Native" scheme="http://wangyeming.github.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React Native in Android的项目实战02--Android接口和View封装</title>
    <link href="http://wangyeming.github.com/2019/03/14/react-natvie-for-android-02/"/>
    <id>http://wangyeming.github.com/2019/03/14/react-natvie-for-android-02/</id>
    <published>2019-03-14T10:50:49.000Z</published>
    <updated>2019-09-09T12:30:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们看到rn for Adnroid的模版工程，基于ReactActivity，仅仅几十行代码就完成了一个简单的RN示例工程。上一章结束后也遗留了很多问题，今天先说一说rn中是如何调用客户端提供的接口的。又是如何使用客户端封装的View的呢？</p><a id="more"></a><h1 id="如何调试rn代码"><a href="#如何调试rn代码" class="headerlink" title="如何调试rn代码"></a>如何调试rn代码</h1><p>rn的调试可以通过chrome的插件<a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi" target="_blank" rel="noopener">React Developer Tools</a>来做。</p><p>然后在dev环境下，点击</p><p><img src="/img/2019-03-14-react-natvie-for-android-02-01.jpg" alt></p><p>chrome会自动打开一个页面 <a href="http://localhost:8081/debugger-ui/" target="_blank" rel="noopener">http://localhost:8081/debugger-ui/</a> 在这个页面下，你可以进行rn代码的调试。例如<br>鼠标右键-菜单点击检查-打开控制台，点击Console，你就可以看到js里面输出的log信息了。</p><p><img src="/img/2019-03-14-react-natvie-for-android-02-02.png" alt></p><h1 id="ReactPackage和NativeModule"><a href="#ReactPackage和NativeModule" class="headerlink" title="ReactPackage和NativeModule"></a>ReactPackage和NativeModule</h1><h2 id="ReactPackage"><a href="#ReactPackage" class="headerlink" title="ReactPackage"></a>ReactPackage</h2><p>首先看下代码(省略了注释信息)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReactPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nonnull</span></span><br><span class="line">  <span class="function">List&lt;NativeModule&gt; <span class="title">createNativeModules</span><span class="params">(@Nonnull ReactApplicationContext reactContext)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nonnull</span></span><br><span class="line">  <span class="function">List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(@Nonnull ReactApplicationContext reactContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactPackage提供了封装了两个方法, createNativeModules()返回的是NativeModule的列表，createViewManagers()返回的是ViewManager的列表。</p><h2 id="NativeModule"><a href="#NativeModule" class="headerlink" title="NativeModule"></a>NativeModule</h2><p>NativeModule就是native模块提供给js接口的模块。来看一下NativeModule的代码(省略了注释信息)，同样也是一个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DoNotStrip</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NativeModule</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">NativeMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(JSInstance jsInstance, ReadableArray parameters)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nonnull</span> <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">canOverrideExistingModule</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onCatalystInstanceDestroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从注释中我们可以看到，rn提供了NativeModule的一些默认实现，例如抽象类<strong>BaseJavaModule</strong>和他的子抽象类<strong>ReactContextBaseJavaModule</strong>。我们只要继承其中某个module，就可以实现自己的方法。同时注释里也提到了C++方法的注册</p><pre><code>{@link NativeModule}s whose implementation is written in C++must not provide any Java code (so they can be reused on other platforms), and instead shouldregister themselves using {@link CxxModuleWrapper}.</code></pre><h2 id="ViewManager"><a href="#ViewManager" class="headerlink" title="ViewManager"></a>ViewManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ReactPropertyHolder</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewManager</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">View</span>, <span class="title">C</span> <span class="keyword">extends</span> <span class="title">ReactShadowNode</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">BaseJavaModule</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewManager的代码比较长，我们可以看到，ViewManager本身也是BaseJavaModule的一个实现。具体用法我们下面结合例子来讲。</p><h1 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h1><h2 id="封装native-java方法"><a href="#封装native-java方法" class="headerlink" title="封装native java方法"></a>封装native java方法</h2><p>首先我们继承ReactContextBaseJavaModule</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonBridgeModule</span> <span class="keyword">extends</span> <span class="title">ReactContextBaseJavaModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonBridgeModule</span><span class="params">(ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里的名字就是js里面找到指定module的key</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"CommonBridgeModule"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供给rn的方法要加注解</span></span><br><span class="line">    <span class="meta">@ReactMethod</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(String tag, String message, Callback callback)</span> </span>&#123;</span><br><span class="line">        Log.d(tag, message);</span><br><span class="line">        callback.invoke(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着定义ReactPackage，把刚才的Module封装进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonReactPackage</span> <span class="keyword">implements</span> <span class="title">ReactPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;NativeModule&gt; <span class="title">createNativeModules</span><span class="params">(@Nonnull ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.asList(<span class="keyword">new</span> CommonBridgeModule(reactContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ViewManager&gt; <span class="title">createViewManagers</span><span class="params">(@Nonnull ReactApplicationContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，找到注册ReactPackage的地方，模版代码里是创建ReactNativeHost的地方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReactNativeHost mReactNativeHost = <span class="keyword">new</span> ReactNativeHost(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUseDeveloperSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">                    <span class="keyword">new</span> MainReactPackage(), </span><br><span class="line">                    <span class="comment">//添加自定义ReactPackage</span></span><br><span class="line">                    <span class="keyword">new</span> CommonReactPackage()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> String <span class="title">getJSMainModuleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>最后我们在js里面调用一下试试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;NativeModules&#125; <span class="keyword">from</span> <span class="string">"react-native"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> CommonBridgeModule = NativeModules.CommonBridgeModule;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">Props</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">//调接口</span></span><br><span class="line">    CommonBridge.logMessage(<span class="string">'demo'</span>, <span class="string">'hello react native'</span>, (result) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'demo'</span>, result)</span><br><span class="line">     &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><p>android studio控制台输出：</p><pre><code>/com.awesomeproject I/ReactNativeJS: &apos;demo&apos;, 0/com.awesomeproject D/demo: hello react native</code></pre><p>Chrome的React Developer Tools插件输出：</p><pre><code>demo 0</code></pre><h2 id="封装Android-View"><a href="#封装Android-View" class="headerlink" title="封装Android View"></a>封装Android View</h2><p>这里我们封装AppCompatButton提供给rn使用,首先是实现ViewManager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppCompactButtonViewManager</span> <span class="keyword">extends</span> <span class="title">SimpleViewManager</span>&lt;<span class="title">AppCompatButton</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AppCompatButton"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AppCompatButton <span class="title">createViewInstance</span><span class="params">(@Nonnull ThemedReactContext reactContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AppCompatButton(reactContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ReactProp</span>(name = <span class="string">"buttonText"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setButtonText</span><span class="params">(AppCompatButton appCompatButton, String buttonText)</span> </span>&#123;</span><br><span class="line">        appCompatButton.setText(buttonText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装进ReactPackage以及注册到rn当中的步骤和前面一样，这里就不多说了。</p><p>接着我们修改rn这边代码：</p><p>这里我们用到了一个node包 create-react-class 需要执行npm install，然后重新npm start。</p><p>规范一点写，我们新建一个AppCompatButtonControl.js文件,然后将AppCompatButton封装成AppCompatButtonControl</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">import</span> createReactClass <span class="keyword">from</span> <span class="string">'create-react-class'</span>;</span><br><span class="line"><span class="keyword">const</span> NativeMethodsMixin = <span class="built_in">require</span>(<span class="string">'NativeMethodsMixin'</span>);</span><br><span class="line"><span class="keyword">const</span> React = <span class="built_in">require</span>(<span class="string">'React'</span>);</span><br><span class="line"><span class="keyword">const</span> View = <span class="built_in">require</span>(<span class="string">'View'</span>);</span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">const</span> requireNativeComponent = <span class="built_in">require</span>(<span class="string">'requireNativeComponent'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> AppCompatButtonControl = createReactClass(&#123;</span><br><span class="line"></span><br><span class="line">    mixins: [NativeMethodsMixin],</span><br><span class="line"></span><br><span class="line">    propTypes: &#123;</span><br><span class="line">        ...View.propTypes,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * set button text</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        buttonText: PropTypes.string,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;AppCompatButton</span><br><span class="line">                &#123;...this.props&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> componentName = <span class="string">'AppCompatButton'</span>;</span><br><span class="line"><span class="keyword">let</span> AppCompatButton = requireNativeComponent(</span><br><span class="line">    componentName,</span><br><span class="line">    AppCompatButtonControl</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;AppCompatButtonControl&#125;</span><br></pre></td></tr></table></figure><p>最后，在布局中，直接使用<appcompatbuttoncontrol>标签</appcompatbuttoncontrol></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!&lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;To get started, edit App.js&lt;/Text&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;&#123;instructions&#125;&lt;/Text&gt;</span><br><span class="line">        &lt;AppCompatButtonControl style=&#123;&#123;width: <span class="number">200</span>, height:<span class="number">50</span>&#125;&#125; buttonText=&#123;<span class="string">'按钮'</span>&#125; /&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>最终效果如下图所示：</p><p><img src="/img/2019-03-14-react-natvie-for-android-02-03.png" alt></p><h1 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h1><p>本节简单介绍了利用Chrome插件调试rn代码的方式，并通过ReactPackage和NativeModule，介绍了如何给rn提供安卓接口以及安卓封装的View，算是比较基础入门的知识。下一篇我们讲一讲如何基于ReactRootView封装RN Fragment</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们看到rn for Adnroid的模版工程，基于ReactActivity，仅仅几十行代码就完成了一个简单的RN示例工程。上一章结束后也遗留了很多问题，今天先说一说rn中是如何调用客户端提供的接口的。又是如何使用客户端封装的View的呢？&lt;/p&gt;
    
    </summary>
    
      <category term="React Native in Android的项目实战" scheme="http://wangyeming.github.com/categories/React-Native-in-Android%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
      <category term="React Native" scheme="http://wangyeming.github.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React Native in Android的项目实战01--从RN的官方Demo讲起</title>
    <link href="http://wangyeming.github.com/2019/03/12/react-natvie-for-android-01/"/>
    <id>http://wangyeming.github.com/2019/03/12/react-natvie-for-android-01/</id>
    <published>2019-03-12T06:14:18.000Z</published>
    <updated>2019-09-09T12:30:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们从React Native官方的教程开始，先研究清楚RN默认新建的工程的结构，方便我们后续进行进一步的定制。<br>这一章讲的比较基础，不会过多展开。</p><a id="more"></a><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="JavaScript和ECMAScript"><a href="#JavaScript和ECMAScript" class="headerlink" title="JavaScript和ECMAScript"></a>JavaScript和ECMAScript</h2><p>如果只是从事客户端这边的开发，即使是和RN协同开发，负责中间桥的相关业务，其实不了解JavaScript也不要紧。不过简单了解下也有好处，而且我们最终的项目Demo也有一些RN端的代码。</p><p>推荐一本JavaScript入门书籍 <a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">JavaScript 语言入门教程</a></p><p>ECMAScript又是什么呢？引入一段说明：</p><pre><code>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript）。日常场合，这两个词是可以互换的。</code></pre><p>目前可以简单的了解下ES6.<a href="http://es6.ruanyifeng.com/" target="_blank" rel="noopener">ECMAScript 6 入门</a></p><h2 id="node-js，npm和package-json"><a href="#node-js，npm和package-json" class="headerlink" title="node js，npm和package.json"></a>node js，npm和package.json</h2><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">node js官网</a></p><p>首先要了解node js是什么？</p><pre><code>JavaScript 是一种轻量级的脚本语言。所谓“脚本语言”（script language），指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。JavaScript 也是一种嵌入式（embedded）语言。它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以 JavaScript 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。目前，已经嵌入 JavaScript 的宿主环境有多种，最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</code></pre><p>也就是说，如果我们平时想练习js的语法，和python，java之类的语言可以直接在命令行执行不同,如果不借助浏览器的话，通常我们需要安装node，通过node来加载，编译和运行我们的js脚本。</p><p>npm是nodejs提供的包管理工具。类似brew之于mac os，apt之于linux。</p><p>对我们来说，其实主要就是两条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure><p>关于npm更多的信息和package.json,可以参考下面这篇文章：</p><p><a href="https://juejin.im/entry/598286cb6fb9a03c5b04a4ff" target="_blank" rel="noopener">npm 与 package.json 快速入门</a></p><h2 id="React和React-Native"><a href="#React和React-Native" class="headerlink" title="React和React Native"></a>React和React Native</h2><p>终于说到了我们的主角React Native。说之前有必要了解什么事React。React是针对View层的使用Javascript的UI组件开发库，从设计初衷来说，React是不关心View层具体技术实现的（比如是否web，android，iOS甚至是windows还是macOS）。</p><pre><code>A JavaScript library for building user interfaces</code></pre><p>ReactNative更多的是一个基于React进行iOS和Android原生App开发的框架，包括封装好的UI组件库，同时提供了React组件生成原生APP的能力。</p><pre><code>A framework for building native apps using React</code></pre><p><a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">ReactNative</a></p><h1 id="初探示例工程"><a href="#初探示例工程" class="headerlink" title="初探示例工程"></a>初探示例工程</h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>按照教程的要求,安装好node，脚手架工具react-native-cli，然后利用react-native-cli快速搭建Demo工程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native init AwesomeProject</span><br></pre></td></tr></table></figure><p>执行成功后，我们可以看到文件夹下，包含着这些文件。</p><p><img src="/img/2019-03-12-react-natvie-for-android-01-01.png" alt></p><h2 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h2><h3 id="运行rn工程"><a href="#运行rn工程" class="headerlink" title="运行rn工程"></a>运行rn工程</h3><ul><li>在工程根目录下，执行命令行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>安装node依赖包，成功后，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>这时，系统会执行package.json下scripts里面的start对应的命令：</p><p><img src="/img/2019-03-12-react-natvie-for-android-01-02.png" alt></p><p>这时，rn工程这边的测试服务就开启了,在本地8081端口号上，rn运行起了Metro Bundler服务。关于Metro我们之后再讲。接下来只需要在手机上运行起安卓工程就可以进行测试环境的调试了。</p><h3 id="运行安卓工程"><a href="#运行安卓工程" class="headerlink" title="运行安卓工程"></a>运行安卓工程</h3><p>本文默认是安卓工程师的角度，所以运行安卓工程就不多说了。额外的，我们需要执行一条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb reverse tcp:8081 tcp:8081</span><br></pre></td></tr></table></figure><p>成功连接上本地的rn服务后，会看到Metro Bundler服务开始进行bundle打包，传入正在运行工程的安卓上，代码也就跑起来了。</p><p><img src="/img/2019-03-12-react-natvie-for-android-01-03.png" alt></p><h2 id="了解工程结构"><a href="#了解工程结构" class="headerlink" title="了解工程结构"></a>了解工程结构</h2><p><img src="/img/2019-03-12-react-natvie-for-android-01-01.png" alt></p><p>其中android和ios分别对应着两端的工程项目。package.json是node工程的配置文件, node_module里面是node依赖模块。app.json文件很简单，内容就是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"AwesomeProject"</span>,</span><br><span class="line">  <span class="attr">"displayName"</span>: <span class="string">"AwesomeProject"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中name待会我们在安卓工程代码中会用到。我们重点关心下面两个文件：</p><p>App.js和index.js</p><p>先看index.js的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @format</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;AppRegistry&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;name <span class="keyword">as</span> appName&#125; <span class="keyword">from</span> <span class="string">'./app.json'</span>;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(appName, () =&gt; App);</span><br></pre></td></tr></table></figure><p>很简单,就是根据app.json文件中的name，将<strong>App</strong>这个组件注册为app的根组件。接下来来看App.js的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sample React Native App</span></span><br><span class="line"><span class="comment"> * https://github.com/facebook/react-native</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @format</span></span><br><span class="line"><span class="comment"> * @flow</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Platform, StyleSheet, Text, View&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instructions = Platform.select(&#123;</span><br><span class="line">  ios: <span class="string">'Press Cmd+R to reload,\n'</span> + <span class="string">'Cmd+D or shake for dev menu'</span>,</span><br><span class="line">  android:</span><br><span class="line">    <span class="string">'Double tap R on your keyboard to reload,\n'</span> +</span><br><span class="line">    <span class="string">'Shake or press menu button for dev menu'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">type Props = &#123;&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span>&lt;<span class="title">Props</span>&gt; </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;styles.welcome&#125;&gt;Welcome to React Native!<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">        &lt;Text style=&#123;styles.instructions&#125;&gt;To get started, edit App.js&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Text style=&#123;styles.instructions&#125;&gt;&#123;instructions&#125;&lt;/</span>Text&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const styles = StyleSheet.create(&#123;</span></span><br><span class="line"><span class="regexp">  container: &#123;</span></span><br><span class="line"><span class="regexp">    flex: 1,</span></span><br><span class="line"><span class="regexp">    justifyContent: 'center',</span></span><br><span class="line"><span class="regexp">    alignItems: 'center',</span></span><br><span class="line"><span class="regexp">    backgroundColor: '#F5FCFF',</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  welcome: &#123;</span></span><br><span class="line"><span class="regexp">    fontSize: 20,</span></span><br><span class="line"><span class="regexp">    textAlign: 'center',</span></span><br><span class="line"><span class="regexp">    margin: 10,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  instructions: &#123;</span></span><br><span class="line"><span class="regexp">    textAlign: 'center',</span></span><br><span class="line"><span class="regexp">    color: '#333333',</span></span><br><span class="line"><span class="regexp">    marginBottom: 5,</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><p>App是继承自Component的RN组件，在render()方法中，创建了相应的View，并最终作为app的根组件被注册进来。<br>这里就不多说了，毕竟我们的重点是Android工程中的代码。</p><h2 id="Android工程"><a href="#Android工程" class="headerlink" title="Android工程"></a>Android工程</h2><p>我们来看看RN的模版demo里面，在安卓项目中做了哪些事？</p><ul><li>build gradle文件夹下，添加了RN库的依赖</li></ul><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation <span class="string">"com.facebook.react:react-native:+"</span></span><br></pre></td></tr></table></figure><p>java文件只有两个MainApplication和MainActivity</p><p>MainActivity的代码很简单，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awesomeproject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.facebook.react.ReactActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">ReactActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the name of the main component registered from JavaScript.</span></span><br><span class="line"><span class="comment">     * This is used to schedule rendering of the component.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getMainComponentName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"AwesomeProject"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里示例直接继承了ReactActivity，ReactActivity内部封装了很多native和rn具体配置的接口设置，后面会详细讲到，这里先不多说了。getMainComponentName()方法返回的字符串正是前面rn工程根目录下，app.json文件里面的name。这两者需要确保对应的上。</p><p>再看MainApplication的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.awesomeproject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.facebook.react.ReactApplication;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.ReactNativeHost;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.ReactPackage;</span><br><span class="line"><span class="keyword">import</span> com.facebook.react.shell.MainReactPackage;</span><br><span class="line"><span class="keyword">import</span> com.facebook.soloader.SoLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> <span class="keyword">implements</span> <span class="title">ReactApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReactNativeHost mReactNativeHost = <span class="keyword">new</span> ReactNativeHost(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getUseDeveloperSupport</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> BuildConfig.DEBUG;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> List&lt;ReactPackage&gt; <span class="title">getPackages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Arrays.&lt;ReactPackage&gt;asList(</span><br><span class="line">          <span class="keyword">new</span> MainReactPackage()</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getJSMainModuleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReactNativeHost <span class="title">getReactNativeHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mReactNativeHost;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    SoLoader.init(<span class="keyword">this</span>, <span class="comment">/* native exopackage */</span> <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，RN在Application里实现了ReactApplication，创建了ReactNativeHost对象并通过getReactNativeHost()方法返回。而ReactNativeHost这里实现了有三个方法：</p><p>getUseDeveloperSupport()方法只有当打的debug渠道的包，才会开启dev模式。</p><p>getJSMainModuleName()返回了”index”，看一下方法的注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the name of the main module. Determines the URL used to fetch the JS bundle</span></span><br><span class="line"><span class="comment"> * from the packager server. It is only used when dev support is enabled.</span></span><br><span class="line"><span class="comment"> * This is the first file to be executed once the &#123;<span class="doctag">@link</span> ReactInstanceManager&#125; is created.</span></span><br><span class="line"><span class="comment"> * e.g. "index.android"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getJSMainModuleName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"index.android"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的意思是，仅仅当dev模式下，手机上运行的进程会通过这个字符串名称，去加载此前rn传过来的bundle包的主模块。其实对应着的就是index.js文件。这里提到了<strong>ReactInstanceManager</strong>类，我们后面会具体讲。</p><p>getPackages()方法返回的是ReactPackage的列表。关于<strong>ReactPackage</strong>，其实也很简单，我们Android封装给RN的接口也好，View组件也好，都可以通过ReactPackage在启动RN服务的时候，注册给rn这边。这个我们也放到后面再说。</p><h1 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h1><p>这里简单介绍了rn的一些基础，如何创建，运行rn的模版工程，以及简单的梳理了rn模版工程的目录结构，主要代码的逻辑等。不过随之而来的问题也来了：</p><ul><li>rn模版工程提供了Activity的实现方法，那么如果想要运行在fragment甚至view里，该如何处理</li><li>rn模版工程当中的<strong>ReactInstanceManager</strong>，<strong>ReactPackage</strong>，<strong>ReactNativeHost</strong>都有什么作用？</li><li>Android客户端这边如何给rn提供接口？Android客户端这边如何给rn封装view？</li></ul><p>……等等问题，可以看到，模版代码虽然简单，不过也由于封装层级比较高，很多细节目前还看不出来。所以下一章，我们就深入到内部，研究一下我们刚才提出的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们从React Native官方的教程开始，先研究清楚RN默认新建的工程的结构，方便我们后续进行进一步的定制。&lt;br&gt;这一章讲的比较基础，不会过多展开。&lt;/p&gt;
    
    </summary>
    
      <category term="React Native in Android的项目实战" scheme="http://wangyeming.github.com/categories/React-Native-in-Android%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
      <category term="React Native" scheme="http://wangyeming.github.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>React Native in Android的项目实战[引]</title>
    <link href="http://wangyeming.github.com/2019/03/10/react-natvie-for-android-00/"/>
    <id>http://wangyeming.github.com/2019/03/10/react-natvie-for-android-00/</id>
    <published>2019-03-10T02:04:56.000Z</published>
    <updated>2019-09-09T12:30:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>从本篇起，我将新开一个系列，和大家分享一下我们目前项目中用到的React Native。我会最终实现一个符合项目80%需求的混合开发的Demo，结合代码跟大家一起分享。</p><p><img src="/img/2019-03-10-react-natvie-for-android-00-01.png" alt></p><a id="more"></a><h1 id="RN们正蚕食客户端开发的工作"><a href="#RN们正蚕食客户端开发的工作" class="headerlink" title="RN们正蚕食客户端开发的工作"></a>RN们正蚕食客户端开发的工作</h1><p>最近几年，以React Native为代表的跨平台移动开发框架可以说非常的火热，以近似前端的开发效率，近似原生优于H5的性能，以及更重要的，可以实现客户端的动态化部署的特性，逐渐的替代了很一大部分原生的开发工作。所以说，跨平台开发框架很大程度上，是客户端应用开发者必须要面对的挑战。</p><h1 id="客户端开发可以做的事"><a href="#客户端开发可以做的事" class="headerlink" title="客户端开发可以做的事"></a>客户端开发可以做的事</h1><p>从项目角度而言，集成类似React Native的跨平台移动开发框架的项目中，客户端开发需要做好的工作有：</p><ul><li>客户端工程中以合适的方式集成React Native(是普通的gradle依赖maven仓库的线上包，还是依赖源码？)</li><li>调通客户端与React Native的通信(js如何调用客户端提供的接口？)</li><li>页面的跳转分发(打开一个页面，打开的是native页面，还是rn页面？）</li></ul><h1 id="举一个栗子"><a href="#举一个栗子" class="headerlink" title="举一个栗子"></a>举一个栗子</h1><p>接下来我们将会从这些问题出发，逐步和大家分享安卓当中集成React Native的方式和需要注意的地方。最后我们将会实现一个简单的Demo。Demo实现了以下功能：</p><ul><li>多Tab下嵌入不同的fragment，tab1是native fragment，tab2是react native fragment</li><li>页面跳转通过url的形式进行分发,支持通过url参数的形式，实现四种方式的跳转(native -&gt; native, native -&gt; rn, rn -&gt; native, rn -&gt; native)</li></ul><p>可以看demo运行起来的样子</p><p><img src="/img/2019-03-10-react-natvie-for-android-00-02.png" alt></p><p>上图是我实现的一个Demo，首页底部有两个tab，tab1对应的是原生的Fragment实现,tab2对应的是React Native页面。</p><p>这里总共定义了四个页面，每个页面都对应着一个url。分别用path表示的话是：</p><p>/main   /secondary  /third  /forth</p><p>而客户端和RN都实现了url的形式进行页面的跳转,下面的动图展示了四种跳转方式。</p><p><img src="/img/2019-03-10-react-natvie-for-android-00-03.gif" alt></p><h1 id="子篇索引"><a href="#子篇索引" class="headerlink" title="子篇索引"></a>子篇索引</h1><p><a href="/2019/03/12/react-natvie-for-android-01">React Native in Android的项目实战01–从RN的官方Demo讲起</a><br><a href="/2019/03/14/react-natvie-for-android-02">React Native in Android的项目实战02–Android接口和View封装</a><br><a href="/2019/03/14/react-natvie-for-android-03">React Native in Android的项目实战03–基于ReactRootView封装RN Fragment</a></p><p>待补充</p><h1 id="仓库地址"><a href="#仓库地址" class="headerlink" title="仓库地址"></a>仓库地址</h1><p>待补充</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从本篇起，我将新开一个系列，和大家分享一下我们目前项目中用到的React Native。我会最终实现一个符合项目80%需求的混合开发的Demo，结合代码跟大家一起分享。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-03-10-react-natvie-for-android-00-01.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="React Native in Android的项目实战" scheme="http://wangyeming.github.com/categories/React-Native-in-Android%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"/>
    
    
      <category term="Android" scheme="http://wangyeming.github.com/tags/Android/"/>
    
      <category term="React Native" scheme="http://wangyeming.github.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门5-线性回归(下：梯度下降法实际应用)</title>
    <link href="http://wangyeming.github.com/2019/01/31/tensorflow-introduction-05/"/>
    <id>http://wangyeming.github.com/2019/01/31/tensorflow-introduction-05/</id>
    <published>2019-01-31T10:05:50.000Z</published>
    <updated>2019-09-09T12:30:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>线性回归问题最常见的两个方法，一个是最小二乘法，另一个就是<strong>梯度下降</strong>. 上一章我们说明了梯度下降法的原理。现在我们就来看一下线性回归到底是什么类型的问题，以及梯度下降法在线性回归中的实际应用。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-04.svg" alt></p><a id="more"></a><h1 id="线性回归-Linear-regression"><a href="#线性回归-Linear-regression" class="headerlink" title="线性回归 Linear regression"></a>线性回归 Linear regression</h1><h2 id="定义-Definition"><a href="#定义-Definition" class="headerlink" title="定义 Definition"></a>定义 Definition</h2><p>看一下线性回归的定义：</p><pre><code>Linear regression is a linear model, e.g. a model that assumes a linear relationship between the input variables (x) and the single output variable (y). More specifically, that output variable (y) can be calculated from a linear combination of the input variables (x).</code></pre><p><a href="https://en.wikipedia.org/wiki/Linear_regression]" target="_blank" rel="noopener">Linear Regression on Wikipedia</a></p><p><img src="/img/2019-01-29-tensorflow-introduction-04-01.svg" alt></p><h2 id="特征-Features"><a href="#特征-Features" class="headerlink" title="特征 Features"></a>特征 Features</h2><p>每一份训练的样本中都包含了用于描述样本的特征，也就是变量。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-02.svg" alt></p><p>n 表示特征数<br>R<sup>n+1</sup> 表示包含n+1个实数的向量</p><p>对于单变量的线性回归，特征数n是1，只有x<sub>0</sub>一个特征</p><h2 id="参数-Parameters"><a href="#参数-Parameters" class="headerlink" title="参数 Parameters"></a>参数 Parameters</h2><p>对于这些特征x<sub>i</sub>而言，每个特征都有一个参数值θ<sub>i</sub></p><p><img src="/img/2019-01-29-tensorflow-introduction-04-03.svg" alt></p><h2 id="假设-Hypothesis"><a href="#假设-Hypothesis" class="headerlink" title="假设 Hypothesis"></a>假设 Hypothesis</h2><p>线性回归问题基于的假设就是，输出值y与X是存在线性关系的。也就可以用下面的表达式进行定义</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-04.svg" alt></p><p>其中θ<sub>i</sub>是参数，也就是我们希望模型能够计算出的结果。<strong>为了方便标记，我们将x<sub>0</sub>定义为1</strong></p><h2 id="价值函数-Cost-Function"><a href="#价值函数-Cost-Function" class="headerlink" title="价值函数 Cost Function"></a>价值函数 Cost Function</h2><p>线型回归问题终究是基于线性关系的假设，那如何衡量我们计算出的<strong>θ</strong>的准确性呢？那显然需要用到cost function(价值函数)。也可以称作误差方程，损失函数等等。</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-11.svg" alt></p><p>x<sup>i</sup> - 第i个样本的特征值</p><p>y<sup>i</sup> - 第i个样本的输出值</p><p>m - 样本个数</p><p>在线性回归中，损失函数通常为样本输出和假设函数的差取平方。这里就是采用这种方式。</p><h1 id="线性回归中的梯度下降"><a href="#线性回归中的梯度下降" class="headerlink" title="线性回归中的梯度下降"></a>线性回归中的梯度下降</h1><h2 id="代数表示方法"><a href="#代数表示方法" class="headerlink" title="代数表示方法"></a>代数表示方法</h2><h3 id="样本"><a href="#样本" class="headerlink" title="样本"></a>样本</h3><p>首先我们有n个样本数据</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-08.svg" alt></p><p>也可以表示为：</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-14.svg" alt>  </p><h3 id="价值函数求梯度"><a href="#价值函数求梯度" class="headerlink" title="价值函数求梯度"></a>价值函数求梯度</h3><p>接着我们对价值函数(误差方程)求偏导：</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-12.svg" alt>  </p><h3 id="确定参数的初始值"><a href="#确定参数的初始值" class="headerlink" title="确定参数的初始值"></a>确定参数的初始值</h3><p><img src="/img/2019-01-31-tensorflow-introduction-05-09.svg" alt></p><p>例如我们可以初始化都赋值成1</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-13.svg" alt></p><h3 id="生成参数的转移矢量"><a href="#生成参数的转移矢量" class="headerlink" title="生成参数的转移矢量"></a>生成参数的转移矢量</h3><p>根据学习速率确定步长α,乘以损失函数的梯度，这样我们就能得到参数的转移矢量，模就是θ的梯度下降距离</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-10.svg" alt></p><h3 id="生成新参数"><a href="#生成新参数" class="headerlink" title="生成新参数"></a>生成新参数</h3><p>参数的转移矢量的大小，如果所有的θ的梯度下降距离都小于阈值ε,那么计算终止。如果不满足要求，那么</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-15.svg" alt></p><h2 id="矩阵表示"><a href="#矩阵表示" class="headerlink" title="矩阵表示"></a>矩阵表示</h2><h3 id="样本-1"><a href="#样本-1" class="headerlink" title="样本"></a>样本</h3><p>样本可以用矩阵X Y表示。</p><h3 id="假设函数"><a href="#假设函数" class="headerlink" title="假设函数"></a>假设函数</h3><p><img src="/img/2019-01-29-tensorflow-introduction-04-23.svg" alt></p><p><strong>θ</strong>表示n<em>1的参数矩阵，*</em>X**表示nx1的自变量矩阵</p><h3 id="价值函数"><a href="#价值函数" class="headerlink" title="价值函数"></a>价值函数</h3><p>价值函数的定义也用矩阵形式表示：</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-24.svg" alt></p><h3 id="价值函数的梯度"><a href="#价值函数的梯度" class="headerlink" title="价值函数的梯度"></a>价值函数的梯度</h3><p><img src="/img/2019-01-31-tensorflow-introduction-05-16.svg" alt></p><h3 id="确定参数的初始值-1"><a href="#确定参数的初始值-1" class="headerlink" title="确定参数的初始值"></a>确定参数的初始值</h3><p>这里我们同样把参数初始化都赋值成1</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-17.svg" alt></p><h3 id="生成参数的转移矢量-1"><a href="#生成参数的转移矢量-1" class="headerlink" title="生成参数的转移矢量"></a>生成参数的转移矢量</h3><p><img src="/img/2019-01-31-tensorflow-introduction-05-19.svg" alt></p><h3 id="生成新参数-1"><a href="#生成新参数-1" class="headerlink" title="生成新参数"></a>生成新参数</h3><p>参数的转移矢量的大小，如果所有的θ的梯度下降距离都小于阈值ε,那么计算终止。如果不满足要求，那么</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-18.svg" alt></p><h1 id="过拟合及解决方案-Overfitting-and-Solution"><a href="#过拟合及解决方案-Overfitting-and-Solution" class="headerlink" title="过拟合及解决方案 Overfitting and Solution"></a>过拟合及解决方案 Overfitting and Solution</h1><h2 id="过拟合-Overfitting"><a href="#过拟合-Overfitting" class="headerlink" title="过拟合 Overfitting"></a>过拟合 Overfitting</h2><p>什么是过拟合？简单来说就是机器学习模型过于执着于完美。我们知道实际中的数据肯定是包含随机误差的，以线性回归问题为例，我们训练器学习模型，去找到一条符合我们要求的回归方程即可。而数据点由于包含误差，或者本身回归方程本身也只是近似解，势必会有一些点不落在回归方程上。过拟合又是什么呢？就是为了让结果尽可能的好看(误差方程的值尽可能的小)，而推算出极其复杂的模型，违背了我们寻求简单近似回归方程的本意。</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-01.png" alt></p><p>其它问题例如分类问题，也会有过拟合的问题。</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-02.png" alt></p><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-05-overfitting/" target="_blank" rel="noopener">莫凡 有趣的机器学习 过拟合 (Overfitting)</a></p><h2 id="解决方案-Solution"><a href="#解决方案-Solution" class="headerlink" title="解决方案 Solution"></a>解决方案 Solution</h2><p>一个解决思路是提高样本量。小样本下个例容易被当做普通情况，而样本量足够大的话，会减少机器学习模型过拟合的问题。</p><h3 id="正规化-Regularization"><a href="#正规化-Regularization" class="headerlink" title="正规化 Regularization"></a>正规化 Regularization</h3><p>另一个解决办法是<strong>正规化</strong>。在下图中，蓝色的线代表的方程虽然误差较红色的大，但显然是更优于红色的线的。</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-03.png" alt></p><p>正规化的解决思路就是让红色的回归方程在增加参数导致复杂化的时候，付出相应的代价。换句话说，我们对误差方程中，参数的复杂程度也做为一个评判标准，太复杂的结果误差就大，这样就可以避免过拟合的问题。</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-04.png" alt></p><p>如上图所示，我们在误差方程的后面加上只跟参数相关的部分，平方和的正规化称为L2正规化，绝对值的和称为L1正规化。</p><p>具体可以参考：</p><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-09-l1l2regularization/" target="_blank" rel="noopener">莫凡 有趣的机器学习 L1 / L2 正规化 (Regularization)</a></p><h2 id="线性回归的正规化"><a href="#线性回归的正规化" class="headerlink" title="线性回归的正规化"></a>线性回归的正规化</h2><p>这里假设我们采用L2正规化的方法，更新我们的误差方程：</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-05.svg" alt></p><p>λ是正规化参数，值得注意的是，对于θ<sub>0</sub>，也就是参数项，我们不应该去正规化它。</p><p>这样的话，第四步的计算公式更新为：</p><p><img src="/img/2019-01-31-tensorflow-introduction-05-07.svg" alt>　</p><h1 id="参考-References"><a href="#参考-References" class="headerlink" title="参考 References"></a>参考 References</h1><ul><li><p><a href="https://github.com/trekhleb/homemade-machine-learning/blob/master/homemade/linear_regression/README.md" target="_blank" rel="noopener">trekhleb/homemade-machine-learning linear_regression/README</a></p></li><li><p><a href="https://www.cnblogs.com/pinard/p/5970503.html" target="_blank" rel="noopener">刘建平Pinard 梯度下降（Gradient Descent）小结</a></p></li><li><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-05-overfitting/" target="_blank" rel="noopener">莫凡 有趣的机器学习 过拟合 (Overfitting)</a></p></li><li><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/ML-intro/3-09-l1l2regularization/" target="_blank" rel="noopener">莫凡 有趣的机器学习 L1 / L2 正规化 (Regularization)</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线性回归问题最常见的两个方法，一个是最小二乘法，另一个就是&lt;strong&gt;梯度下降&lt;/strong&gt;. 上一章我们说明了梯度下降法的原理。现在我们就来看一下线性回归到底是什么类型的问题，以及梯度下降法在线性回归中的实际应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-01-29-tensorflow-introduction-04-04.svg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://wangyeming.github.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门4-线性回归(中：梯度下降法的原理)</title>
    <link href="http://wangyeming.github.com/2019/01/29/tensorflow-introduction-04/"/>
    <id>http://wangyeming.github.com/2019/01/29/tensorflow-introduction-04/</id>
    <published>2019-01-29T06:28:42.000Z</published>
    <updated>2019-09-09T12:30:06.613Z</updated>
    
    <content type="html"><![CDATA[<p>上一章我们使用TensorFlow搭建了一个非常简单的关于单参数线性回归的神经网络，并取得了非常好的运行效果。在分析线性回归前，我们有必要针对梯度下降法做一个介绍，看看梯度下降法到底是怎么一回事？</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-14.png" alt></p><a id="more"></a><h1 id="基础-Basic"><a href="#基础-Basic" class="headerlink" title="基础 Basic"></a>基础 Basic</h1><h2 id="多元函数"><a href="#多元函数" class="headerlink" title="多元函数"></a>多元函数</h2><p>首先引出多元函数的概念。在实际问题中尝尝要研究多个变量之间的关系。线性回归问题中同样如此，上一章y关于x的线性回归方程显然只有x一个变量，也就是一元函数。而真实情况下，变量的数目远远不止一个。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-09.svg" alt></p><h2 id="方向倒数和偏导数"><a href="#方向倒数和偏导数" class="headerlink" title="方向倒数和偏导数"></a>方向倒数和偏导数</h2><p>对于一元函数而言，x<sub>0</sub>点导数也就是该点切线的斜率。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-06.jpg" alt></p><p>导数的定义是</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-08.svg" alt></p><p>而由单侧极限引申出<strong>单侧导数</strong>，也就是<strong>左导数</strong>，<strong>右导数</strong></p><p><img src="/img/2019-01-29-tensorflow-introduction-04-10.svg" alt></p><p><img src="/img/2019-01-29-tensorflow-introduction-04-11.svg" alt></p><p>对于<strong>多元函数</strong>而言，任意一个点的导数可能有无数个。想象一个漏斗曲面上任意一点，经过该点我们显然可以沿着不同的方向做无数条切线，而这些切线的斜率都是该点的导数。也就是<strong>全导数</strong>。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-07.jpg" alt></p><p>而这些不同方向的导数我们称之为<strong>方向导数</strong></p><p><img src="/img/2019-01-29-tensorflow-introduction-04-12.svg" alt></p><p>其中<strong>l</strong>是方向向量，<strong>e</strong><sub>l</sub>是<strong>l</strong>方向上的单位方向向量。</p><pre><code>方向导数实际上是函数f在x&lt;sup&gt;0&lt;/sup&gt;处沿l方向关于距离的变化率。</code></pre><p><strong>偏导数</strong>又是什么概念呢，其实就是对函数中某个变量求导数。例如二元函数f(x,y)在(x<sub>0</sub>, y<sub>0</sub>)点假设可导，那么它的方向导数当中，x轴正方向导数，x轴负方向导数，y轴正方向导数，y轴负方向导数都是它的<strong>偏导数</strong>。</p><p><a href="https://www.zhihu.com/question/26966355/answer/154857139" target="_blank" rel="noopener">什么是全导数？ - 马同学的回答 - 知乎</a></p><h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><pre><code>梯度：是一个矢量，其方向上的方向导数最大，其大小正好是此最大方向导数。</code></pre><p>从直观的角度来说，以爬山为例，三维空间我们建立起高度(z)关于经纬度(x, y)的二元函数。所谓的梯度也就是，当你站在山的任意一个位置时，想爬山的你其实有无数个方向可以选择。而上山角度最陡峭，也就是爬山最快的那个方向，就是梯度得方向，而这个方向的导数的值，也就是梯度的模。没错，梯度是个矢量，有大小和方向。</p><p>从数学角度，函数</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-09.svg" alt></p><p>的如果在点<strong>x<sub>0</sub></strong>处可微，那么f在<strong>x<sub>0</sub></strong>的梯度就是这个点的偏导数，记作<strong>grad</strong> f(<strong>x<sub>0</sub></strong>) 或 ∇ f(<strong>x<sub>0</sub></strong>)</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-13.svg" alt></p><p>[如何直观形象的理解方向导数与梯度以及它们之间的关系？ - 马同学的回答 - 知乎]<br>(<a href="https://www.zhihu.com/question/36301367/answer/156102040" target="_blank" rel="noopener">https://www.zhihu.com/question/36301367/answer/156102040</a>)</p><h1 id="梯度下降-Gradient-Descent"><a href="#梯度下降-Gradient-Descent" class="headerlink" title="梯度下降 Gradient Descent"></a>梯度下降 Gradient Descent</h1><h2 id="一元函数的梯度下降"><a href="#一元函数的梯度下降" class="headerlink" title="一元函数的梯度下降"></a>一元函数的梯度下降</h2><p>我们总算了解了梯度的概念。那么梯度下降到底是个什么样的方法呢？</p><p>简而言之就是沿着梯度的方向，尝试找到误差方程的最小值。</p><p>什么意思？还是以最简单的一元函数为例，假设图中的曲线是我们的误差方程曲线，小球的位置就是我们随机给的初始值。根据这个初始值，我们能得到误差方程的初始函数值。我们接下来尝试沿着该点的梯度的方向，去移动这个初始点。(为什么是梯度而不是其他的方向导数，因为梯度其方向上的方向导数最大，也就是最快，有捷径我们自然不会去绕远路)。如此反复之后，直到我们获得的误差方程的的值小于我能接受的范围，那么最终小球的位置就是我们要找的值。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-14.png" alt></p><p>这里很显然带来了两个问题。</p><ol><li>我找到的点，就一定是最低点吗？也就是说，我找到的点，就一定是误差方程的最小值点吗？ </li><li>梯度的方向有了，那小球每次移动的距离是多少？</li></ol><p>第一个问题显然，我们无法保证找到的点就一定是最值点。根据误差方程，初始位置，甚至是步长的不同，我们很可能找到的是一个极值点。形象点说，下山的时候，你走了一段路，发现来到了一处谷底，这个谷底一定是山脚吗？不一定，它也可能只是山上的一处低处。当然，图中实例的曲线，显然是一个凸函数，那我们找到的极值点也一定是它的最值点。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-17.png" alt></p><p>第二个问题，也就是步长的问题，这个和初始点的位置一样，我们可以手动去设置它的值，也就是学习速率。如下图所示，学习速率太小可能导致计算次数变多，时间变得很长。而学习速率过大，则很可能导致一直在极值点附近跳跃，到达不了理想的位置。所以，合理的学习速率非常重要。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-15.png" alt></p><p><a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/1-1-C-gradient-descent/" target="_blank" rel="noopener">莫烦 神经网络 梯度下降</a></p><h2 id="多元函数的梯度下降及算法"><a href="#多元函数的梯度下降及算法" class="headerlink" title="多元函数的梯度下降及算法"></a>多元函数的梯度下降及算法</h2><p>二元函数的梯度下降也可以直观的描述。看下图就好，这里就不多说了。</p><p><img src="/img/2019-01-29-tensorflow-introduction-04-16.png" alt></p><p>同理多元函数的梯度下降也是类似的,这里就不赘述了。　　　　　　　　</p><h1 id="参考-References"><a href="#参考-References" class="headerlink" title="参考 References"></a>参考 References</h1><ul><li><p><a href="https://github.com/trekhleb/homemade-machine-learning/blob/master/homemade/linear_regression/README.md" target="_blank" rel="noopener">trekhleb/homemade-machine-learning linear_regression/README</a></p></li><li><p><a href="https://www.zhihu.com/question/26966355/answer/154857139" target="_blank" rel="noopener">什么是全导数？ - 马同学的回答 - 知乎</a></p></li><li><p><a href="https://www.zhihu.com/question/36301367/answer/156102040" target="_blank" rel="noopener">如何直观形象的理解方向导数与梯度以及它们之间的关系？ - 马同学的回答 - 知乎</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一章我们使用TensorFlow搭建了一个非常简单的关于单参数线性回归的神经网络，并取得了非常好的运行效果。在分析线性回归前，我们有必要针对梯度下降法做一个介绍，看看梯度下降法到底是怎么一回事？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-01-29-tensorflow-introduction-04-14.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://wangyeming.github.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门3-线性回归(上：实战)</title>
    <link href="http://wangyeming.github.com/2019/01/28/tensorflow-introduction-03/"/>
    <id>http://wangyeming.github.com/2019/01/28/tensorflow-introduction-03/</id>
    <published>2019-01-28T09:21:35.000Z</published>
    <updated>2019-09-09T12:30:06.612Z</updated>
    
    <content type="html"><![CDATA[<p>回归问题，尤其是单变量的线性回归问题，一般是机器学习中入门时最常举的例子。我们也不例外，就从线性回归问题聊起。我们上篇先看一个简单的实现例子，下篇我们再聊涉及理论的方面。</p><p><img src="/img/2019-01-28-tensorflow-introduction-03-03.gif" alt></p><a id="more"></a><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>为了避免一开始就丟公式和原理，我们先看代码，有个感性上的认识。这里我们以『单变量的线性回归』为例.</p><h2 id="库的导入"><a href="#库的导入" class="headerlink" title="库的导入"></a>库的导入</h2><p>首先是导入相关库</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="生成随机数据"><a href="#生成随机数据" class="headerlink" title="生成随机数据"></a>生成随机数据</h2><p>接着是原始数据，这里我们通过numpy的随机函数，创建100个(x, y)的点，满足 y = 0.1x + 0.3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x_data = np.random.rand(<span class="number">100</span>).astype(np.float32)</span><br><span class="line">y_data = x_data * <span class="number">0.1</span> + <span class="number">0.3</span></span><br></pre></td></tr></table></figure><p>这里因为是我们自己生成的数据，我们自然知道可以用线性回归去拟合这些点。<br>同时数据样本的值比较小，数据标准化的步骤我们也省略。下面直接开始搭建深度学习网络。</p><h2 id="构建张量"><a href="#构建张量" class="headerlink" title="构建张量"></a>构建张量</h2><p>网络搭建的第一步，我们需要去定义出我们通过深度学习网络，到底要计算出什么样的结果。很显然，假如我只知道我的数据大致符合：</p><pre><code>y = w*x+b</code></pre><p>这样的线型方程。那么，我希望深度学习网络能顺利的输出w和b的值，接近我预设的真实值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weights = tf.Variable(tf.random_uniform([<span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">biases = tf.Variable(tf.zeros([<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>只要你看了上一章<a href="2019/01/28/tensorflow-introduction-02">TensorFlow入门2-基础概念</a>, 对这里张量的定义肯定不会太陌生。为了更直观的了解到我们这两行到底做了什么，我们可以拆开了这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weights_initial_value = tf.random_uniform(shape=[<span class="number">1</span>], minval=<span class="number">-1.0</span>, maxval=<span class="number">1.0</span>)</span><br><span class="line">weights = tf.Variable(initial_value=weights_initial_value)</span><br><span class="line">biases_initial_value = tf.zeros(shape=[<span class="number">1</span>])</span><br><span class="line">biases = tf.Variable(initial_value=biases_initial_value)</span><br></pre></td></tr></table></figure><ul><li>定义张量y，也就是我们的预测值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 张量支持四则运算</span></span><br><span class="line">y = weights * x_data + biases</span><br></pre></td></tr></table></figure><p>到这一步，我们定义了三个张量，weights和biases分别对应着公式中的w和b，而y是预测值。我们可以打印出这三个张量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;tf.Variable &apos;Variable:0&apos; shape=(1,) dtype=float32_ref&gt; </span><br><span class="line">&lt;tf.Variable &apos;Variable_1:0&apos; shape=(1,) dtype=float32_ref&gt; </span><br><span class="line">Tensor(&quot;add:0&quot;, shape=(100,), dtype=float32)</span><br></pre></td></tr></table></figure><h2 id="定义损失函数和优化器"><a href="#定义损失函数和优化器" class="headerlink" title="定义损失函数和优化器"></a>定义损失函数和优化器</h2><ul><li>接下来我们需要定义的是损失函数和优化器。前者是我们评价预测结果好坏的计算方法，后者则是深度学习网络根据预测值进行迭代优化的真正的方法。这里我们选用的是梯度下降法。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入张量是预测值和实际值的平方差，实际损失是通过tf.math.reduce_mean方法定义的求均值的算术操作</span></span><br><span class="line">loss = tf.math.reduce_mean(input_tensor=tf.square(y - y_data))</span><br><span class="line"><span class="comment"># 定义梯度下降作为优化器,学习速率是0.5</span></span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 定义实际操作就是使用梯度下降优化器去最小化损失函数</span></span><br><span class="line">train = optimizer.minimize(loss)</span><br></pre></td></tr></table></figure><h2 id="创建会话并运行"><a href="#创建会话并运行" class="headerlink" title="创建会话并运行"></a>创建会话并运行</h2><p>到了真正开始执行运算的一步了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记得初始化变量</span></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">201</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        print(step, sess.run(weights), sess.run(biases))</span><br></pre></td></tr></table></figure><h1 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h1><pre><code>[0.4496472] [0.]0 [0.4820045] [0.12873188]20 [0.18697067] [0.25420249]40 [0.12046056] [0.28922576]60 [0.10481351] [0.2974653]80 [0.10113242] [0.2994037]100 [0.1002664] [0.29985973]120 [0.10006267] [0.29996702]140 [0.10001475] [0.29999223]160 [0.10000348] [0.2999982]180 [0.10000083] [0.29999956]200 [0.1000002] [0.29999992]</code></pre><p>可以看到，深度学习网络，通过梯度下降方法，经过201次的训练，已经可以很精确的算出w和b的值。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># create data</span></span><br><span class="line">x_data = np.random.rand(<span class="number">100</span>).astype(np.float32)</span><br><span class="line">y_data = x_data * <span class="number">0.1</span> + <span class="number">0.3</span></span><br><span class="line"></span><br><span class="line">weights = tf.Variable(tf.random_uniform([<span class="number">1</span>], <span class="number">-1.0</span>, <span class="number">1.0</span>))</span><br><span class="line">biases = tf.Variable(tf.zeros([<span class="number">1</span>]))</span><br><span class="line">y = weights * x_data + biases</span><br><span class="line"></span><br><span class="line">loss = tf.math.reduce_mean(tf.square(y - y_data))</span><br><span class="line">optimizer = tf.train.GradientDescentOptimizer(<span class="number">0.5</span>)</span><br><span class="line">train = optimizer.minimize(loss)</span><br><span class="line"></span><br><span class="line">init = tf.global_variables_initializer()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">201</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        print(step, sess.run(weights), sess.run(biases))</span><br></pre></td></tr></table></figure><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><h2 id="数据增加噪音"><a href="#数据增加噪音" class="headerlink" title="数据增加噪音"></a>数据增加噪音</h2><p>通常情况下，我们的数据不会像我们之前展示的那样的完美，所以我们有必要给数据增加上噪音偏差，让它不会恰好完美的落在一条直线上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x_data = np.random.rand(<span class="number">100</span>).astype(np.float32)</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, x_data.shape).astype(np.float32)</span><br><span class="line">y_data = x_data * <span class="number">0.5</span> + <span class="number">0.3</span> + noise</span><br></pre></td></tr></table></figure><h2 id="可视化原始数据"><a href="#可视化原始数据" class="headerlink" title="可视化原始数据"></a>可视化原始数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.scatter(x_data, y_data, s=<span class="number">75</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2019-01-28-tensorflow-introduction-03-01.png" alt></p><p>让我们给图加一个y=0.5x+0.3的线段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">y = x * <span class="number">0.5</span> + <span class="number">0.3</span></span><br><span class="line">plt.plot(x, y, label=<span class="string">'linear'</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2019-01-28-tensorflow-introduction-03-02.png" alt></p><h2 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h2><p>同样的，我们可以动态的展示深度学习网络计算出的结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">201</span>):</span><br><span class="line">    sess.run(train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">20</span> == <span class="number">0</span>:</span><br><span class="line">        weights_value = sess.run(weights)</span><br><span class="line">        biases_value = sess.run(biases)</span><br><span class="line">        print(step, weights_value, biases_value)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'lines'</span> <span class="keyword">in</span> locals().keys():</span><br><span class="line">            <span class="comment"># 移除上一次画的拟合线</span></span><br><span class="line">            ax.lines.remove(lines[<span class="number">0</span>])</span><br><span class="line">        lines = ax.plot(x_data, weights_value * x_data + biases_value)</span><br><span class="line">        plt.pause(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2019-01-28-tensorflow-introduction-03-03.gif" alt></p><pre><code class="python"></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;回归问题，尤其是单变量的线性回归问题，一般是机器学习中入门时最常举的例子。我们也不例外，就从线性回归问题聊起。我们上篇先看一个简单的实现例子，下篇我们再聊涉及理论的方面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-01-28-tensorflow-introduction-03-03.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://wangyeming.github.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门2-基础概念</title>
    <link href="http://wangyeming.github.com/2019/01/28/tensorflow-introduction-02/"/>
    <id>http://wangyeming.github.com/2019/01/28/tensorflow-introduction-02/</id>
    <published>2019-01-28T08:21:35.000Z</published>
    <updated>2019-09-10T13:06:22.223Z</updated>
    
    <content type="html"><![CDATA[<p>接触TensorFlow之前，有必要了解一下TensorFlow当中的基础概念。这里简单梳理下TensorFlow的数据流图, 张量, 会话, 优化器等概念。</p><a id="more"></a><pre><code>本文内容已于2019年09月10日，Google开发者大会当日更新。</code></pre><h1 id="TensorFlow是什么"><a href="#TensorFlow是什么" class="headerlink" title="TensorFlow是什么"></a>TensorFlow是什么</h1><p>TensorFlow是Google推出的开发和训练机器学习模型的核心开源库。</p><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow官网</a></p><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow仓库地址</a></p><p><a href="https://www.tensorflow.org/api_docs/python/tf?hl=zh-cn" target="_blank" rel="noopener">TensorFlow Python API</a></p><p>目前TensorFlow已经发布了<a href="https://www.tensorflow.org/beta/#tensorflow-20" target="_blank" rel="noopener">2.0 RC版</a>，对于目前大面积使用的1.x的接口有了相当程度的改动。本文我们还是以1.x的API为例。</p><h2 id="TensorFlow-模块与Api"><a href="#TensorFlow-模块与Api" class="headerlink" title="TensorFlow 模块与Api"></a>TensorFlow 模块与Api</h2><p><img src="/img/2019-01-28-tensorflow-introduction-02-05.png" alt></p><p>从这张图中我们看到，TensorFlow设计了高中低不同等级的API，并且多语言的兼容性使得开发者可以尽可能的使用自己熟悉的开发语言。</p><h2 id="TensorFlow-架构"><a href="#TensorFlow-架构" class="headerlink" title="TensorFlow 架构"></a>TensorFlow 架构</h2><p><img src="/img/2019-01-28-tensorflow-introduction-02-06.png" alt></p><h1 id="数据流图-Dataflow-graph"><a href="#数据流图-Dataflow-graph" class="headerlink" title="数据流图 Dataflow graph"></a>数据流图 Dataflow graph</h1><p><img src="/img/2019-01-28-tensorflow-introduction-02-01.gif" alt></p><p>这张官网的动图就很直观的表现了TensorFlow是如何构建算法模型的。这里我们不仔细展开，但是也可以发现，动图中表示的是，数据以流的形式在一张包含特定结构的图中进行流动。具体来说：</p><p>TensorFlow用数据流图表示算法模型。</p><p><a href="https://www.tensorflow.org/guide/graphs?hl=zh-cn#why_dataflow_graphs" target="_blank" rel="noopener">为什么使用数据流图？</a></p><p>TensorFlow数据流图是一种申明式的编程规范。</p><p><img src="/img/2019-01-28-tensorflow-introduction-02-02.png" alt></p><p>这里不展开说哈，像Lambda表达式其实就是一种申明式，或者说函数式的编程。</p><p>具体到数据流图，它是由节点和有向边组成, 下面有一张结构图：</p><p><img src="/img/2019-01-28-tensorflow-introduction-02-03.png" alt></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>数据流图中的每个节点对应一个具体的操作。因此，操作是模型功能的实际载体。<br>也就是说，</p><p>节点分为三类：</p><p>存储节点(Variable)    有状态的变量参数,通常用来存储模型参数<br>计算节点(Operation)   无状态的计算或控制操作，主要负责算法逻辑表达或流程控制<br>数据节点(PlaceHolder) 数据的占位符操作,用于描述图外输入数据的属性</p><p>用比较专业的术语来概括下数据流图：</p><pre><code>TensorFlow数据流图描述了算法模型的计算拓扑，其中各个操作(节点)都是抽象的函映射或数学表达式。换句话说，数据流图本身是一个具有计算拓扑或内部结构的『壳』,在用户向数据流图填充数据前，图中并没有执行任何计算。</code></pre><p>从图论的角度，TensorFlow中的图，是一个有向无环图。</p><h1 id="张量-Tensor"><a href="#张量-Tensor" class="headerlink" title="张量 Tensor"></a>张量 Tensor</h1><h2 id="张量-Tensor-和-稀疏张量-Sparse-Tensor"><a href="#张量-Tensor-和-稀疏张量-Sparse-Tensor" class="headerlink" title="张量 Tensor 和 稀疏张量 Sparse Tensor"></a>张量 Tensor 和 稀疏张量 Sparse Tensor</h2><p>官网对<strong>张量</strong>的解释：</p><pre><code>正如名称所示，TensorFlow 这一框架定义和运行涉及张量的计算。张量是对矢量和矩阵向潜在的更高维度的泛化。TensorFlow 在内部将张量表示为基本数据类型的 n 维数组。</code></pre><p>简单来说呢，张量表示某种<strong>相同类型</strong>的多维数组</p><p>在TensorFlow中，张量具有有数据类型和形状两个基本属性。</p><ul><li>数据类型(如浮点型，整型，字符串)</li><li>数组形状(各个维度的大小)</li></ul><p>而相对着稀疏张量 SparseTensor 维度很高，但是数据量稀疏。熟悉线性代数的同学应该知道稀疏矩阵的概念，稀疏张量类似，通过在存储上只存形状和有意义的数值，可以大幅的减少存储空间以及计算量。</p><p>所以，总结一下TensorFlow 张量是什么？</p><ul><li>张量是用来表示多维数组的</li><li>张量是执行操作时的输入或输出数据</li><li>用户通过执行操作来创建或计算张量</li><li>张量的形状不一定在编译时确定，可以在运行时通过形状推断计算得出</li></ul><h2 id="阶-Rank"><a href="#阶-Rank" class="headerlink" title="阶 Rank"></a>阶 Rank</h2><p>tf.Tensor的阶也就是它的维度数。阶的同义词包括：秩（order）、等级（degree）或 n 维（n-dimension）</p><table><thead><tr><th>阶</th><th>数学实例</th></tr></thead><tbody><tr><td>0</td><td>标量（只有大小）</td></tr><tr><td>1</td><td>矢量（大小和方向）</td></tr><tr><td>2</td><td>矩阵（数据表）</td></tr><tr><td>3</td><td>3 阶张量（数据立体）</td></tr><tr><td>4</td><td>n 阶张量（自行想象）</td></tr></tbody></table><p>总结起来，张量就是TensorFlow里的数据单元。根据阶数不同，有0阶的就是一个数字。一阶的向量，二阶的矩阵等等。</p><p><img src="/img/2019-01-28-tensorflow-introduction-02-04.png" alt></p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>先介绍几类特殊的张量</p><p>tf.constant         //常量<br>tf.placeholder      //占位符<br>tf.Variable         //变量</p><p>常量很好理解，就是创建后无法修改值的张量。<br>占位符可以理解为初期不赋值，等到程序实际运行起来，才输入具体值的张量。<br>而通过tf.Variable创建的变量，和普通的张量相比，区别在于</p><ul><li>张量的生命周期通常随依赖的计算完成而结束,内存也随之释放</li><li>变量则常驻内存，在每一步计算时不断更新其值, 以实现模型参数的更新。</li></ul><p>相对来说，变量可以用于维护特定节点的状态,如深度学习或机器学习的模型参数</p><ul><li>首先是导入相关库</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><ul><li>tf.constant可以定义常量张量, tf.Variable可以定义变量张量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义阶为0，数据类型为float, 名称为aaa的常量张量，初始值为1</span></span><br><span class="line">variable1 = tf.constant(value=<span class="number">1</span>, dtype=float, shape=[], name=<span class="string">'aaa'</span>)</span><br><span class="line"><span class="comment"># Tensor("aaa:0", shape=(), dtype=float32)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义阶为0，数据类型为float, 名称为bbb的变量张量，初始值为1</span></span><br><span class="line">variable2 = tf.Variable(initial_value=<span class="number">1</span>, dtype=float, name=<span class="string">'bbb'</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Variable 'bbb:0' shape=() dtype=float32_ref&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义阶为1(形状为(1, ))，数据类型为float, 名称为ccc的变量张量，初始值为[1,1]</span></span><br><span class="line">variable3 = tf.Variable(initial_value=[<span class="number">1</span>, <span class="number">1</span>], dtype=float, name=<span class="string">'ccc'</span>)</span><br><span class="line"><span class="comment"># &lt;tf.Variable 'ccc:0' shape=(2,) dtype=float32_ref&gt;</span></span><br></pre></td></tr></table></figure><p>另外还有一些常用的定义张量的方法，如tf.placeholder定义占位符张量(初始不赋值，运行时才赋值),tf.random_uniform生成随机值张量，tf.zeros定义全零张量等等。</p><p>细心的朋友可能会发现，这里输出的张量信息当中并没有初始化的值信息。那么如何才能打印出张量的值呢？</p><h1 id="会话-Session"><a href="#会话-Session" class="headerlink" title="会话 Session"></a>会话 Session</h1><pre><code>绘画提供了估算张量和执行操作的运行环境,它是发放计算任务的客户端,所有计算任务都由他连接的执行引擎完成。会话允许你执行图或者图的一部分。它为图分配资源(一台或多台机器)，并且保存中间结果和变量的实际值。</code></pre><p>说了一堆概念，下面我们来看看如何创建会话，并在会话中执行一些简单操作：</p><p>创建会话有两种方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建会话</span></span><br><span class="line"><span class="comment"># target 会话连接的执行引擎, graph 会话加载的数据流图, config 会话启动的配置项</span></span><br><span class="line">sess = tf.Session(target=...,graph=...,config=...)</span><br><span class="line"><span class="comment"># 2. 估算张量或执行操作</span></span><br><span class="line">sess.run(...)</span><br><span class="line"><span class="comment"># 3. 关闭会话</span></span><br><span class="line">sess.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">  sess.run(...)</span><br></pre></td></tr></table></figure><p>例如我想打印前面的几个张量的值，那么我可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    print(sess.run(variable1))  <span class="comment">#1.0</span></span><br><span class="line">    <span class="comment"># 下面两行报错 tensorflow.python.framework.errors_impl.FailedPreconditionError: Attempting to use uninitialized value bbb</span></span><br><span class="line">    <span class="comment">#print(sess.run(variable2))  </span></span><br><span class="line">    <span class="comment">#print(sess.run(variable3))</span></span><br></pre></td></tr></table></figure><p>这里我们需要注意，在图中使用变量张量的时候，需要调用初始化方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">init = tf.global_variables_initializer()</span><br><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.run(init)</span><br><span class="line">    print(sess.run(variable1))  <span class="comment">#1.0</span></span><br><span class="line">    print(sess.run(variable2))  <span class="comment">#1.0</span></span><br><span class="line">    print(sess.run(variable3))  <span class="comment">#[1. 1.]</span></span><br></pre></td></tr></table></figure><p>获取张量值的另外两种方法：估算张量(Tensor.val)和执行操作(Operation.run)，这两个方法最终也在内部调用了session.run()方法</p><h1 id="优化器-Optimizer"><a href="#优化器-Optimizer" class="headerlink" title="优化器 Optimizer"></a>优化器 Optimizer</h1><p>在了解优化器之前，需要了解关于<strong>损失函数</strong>和<strong>优化算法</strong>的知识。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数是用来评估特定的模型参数和特定输入时,表达模型输出的推理值和真实值的不一致程度的函数。损失函数L的形式化定义是：</p><p><img src="/img/2019-01-28-tensorflow-introduction-02-07.png" alt></p><p>我们知道，训练模型的最终目的是能够合理的降低损失函数的值，这里可能会存在过拟合的问题，就不展开细说了。</p><h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><p>典型的机器学习和深度学习问题通常都需要转换为最优化问题进行求解。而求解最优化问题的算法成为优化算法。他们通常采用迭代方式进行。首先设定一个初始的可行解，然后基于特定的函数反复重新计算可行解,直到找到一个最优解或者达到预设的收敛条件。不同优化算法采用的迭代策略不同：</p><ul><li>有的使用目标函数的一阶导数，如梯度下降法</li><li>有的使用目标函数的二阶导数，如牛顿法</li><li>有的使用前几轮的迭代信息，如Adam</li></ul><p>简单来说,典型的机器学习和深度学习问题,包含模型定义，损失函数定义，优化算法定义三个部分</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器是优化算法的载体,一次典型的迭代优化应该分为以下三步：</p><ol><li>计算梯度,调用compute_gradients()方法</li><li>处理梯度 用户按照自己需求，处理梯度值,如梯度裁剪和梯度加权</li><li>应用梯度: 调用apply_gradients方法,将处理后的梯度值应用到模型参数。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接触TensorFlow之前，有必要了解一下TensorFlow当中的基础概念。这里简单梳理下TensorFlow的数据流图, 张量, 会话, 优化器等概念。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://wangyeming.github.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow入门1-基础知识</title>
    <link href="http://wangyeming.github.com/2018/12/04/tensorflow-introduction-01/"/>
    <id>http://wangyeming.github.com/2018/12/04/tensorflow-introduction-01/</id>
    <published>2018-12-04T02:13:00.000Z</published>
    <updated>2019-09-09T12:30:06.611Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow是Google开发的一款神经网络的Python外部的结构包, 也是一个采用数据流图来进行数值计算的开源软件库.本篇我们介绍一下深度学习领域的基础知识。</p><a id="more"></a><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><p>我们最常听到的三个名词，<strong>人工智能（Artificial Intelligence）</strong>、<strong>机器学习（Machine Learning）</strong>、<strong>深度学习（Deep Learning）</strong></p><p><strong>人工智能（Artificial Intelligence）</strong> 1956年，几个计算机科学家相聚在达特茅斯会议，提出了“人工智能”的概念，梦想着用当时刚刚出现的计算机来构造复杂的、拥有与人类智慧同样本质特性的机器。人工智能涉及到的研究领域非常之广。包括专家系统、机器学习、进化计算、模糊逻辑、计算机视觉、自然语言处理、推荐系统等。</p><p>而其中<strong>机器学习（Machine Learning）</strong>是一种实现人工智能的方法，而<strong>深度学习（Deep Learning）</strong>则是一种实现机器学习的技术。</p><p><img src="/img/2018-12-04-tensorflow-introduction-01-01.jpg" alt></p><p>具体就不展开说了，可以参考这篇文章：</p><p>[人工智能、机器学习和深度学习的区别? - 育心的回答 - 知乎]<br>(<a href="https://www.zhihu.com/question/57770020/answer/249708509" target="_blank" rel="noopener">https://www.zhihu.com/question/57770020/answer/249708509</a>)</p><p>[机器学习、优化理论、统计分析、数据挖掘、神经网络、人工智能、模式识别之间的关系是什么？]<br>(<a href="https://www.zhihu.com/question/20747381" target="_blank" rel="noopener">https://www.zhihu.com/question/20747381</a>)</p><h1 id="TensorFlow是什么"><a href="#TensorFlow是什么" class="headerlink" title="TensorFlow是什么"></a>TensorFlow是什么</h1><p>引用自<a href="https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/1-1-why/" target="_blank" rel="noopener">莫凡大大的教程</a></p><pre><code>TensorFlow是Google开发的一款神经网络的Python外部的结构包, 也是一个采用数据流图来进行数值计算的开源软件库.TensorFlow 让我们可以先绘制计算结构图, 也可以称是一系列可人机交互的计算操作, 然后把编辑好的Python文件 转换成 更高效的C++, 并在后端进行计算.</code></pre><p><a href="https://www.tensorflow.org/" target="_blank" rel="noopener">TensorFlow官网</a></p><p><a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="noopener">TensorFlow仓库地址</a></p><p>简单来说，TensorFlow作为开源的机器学习框架,它擅长的任务就是训练深度神经网络。它的底层是C++实现的，保障了运算性能。而为了方便开发，TensorFlow同时提供了多种客户端语言，支持使用包括<strong>Python</strong>，<strong>Java</strong>，<strong>Javascript</strong>等语言进行开发。其中<strong>Python</strong>是支持力度最大，最完善的客户端语言。搭配python自带的<strong>numpy</strong>，<strong>pandas</strong>，<strong>matplot</strong>等计算和画图的库，我们可以很方便的利用<strong>python</strong>运行TensorFlow程序，搭建深度神经网络，进行机器学习。</p><p>如果你对<strong>python</strong>，或者<strong>numpy</strong>，<strong>pandas</strong>，<strong>matplot</strong>不太熟悉，可以参考前面的博客：</p><p><a href="/2018/09/04/machine-learning-base-python/">机器学习基础1–python</a><br><a href="/2018/09/04/machine-learning-base-numpy/">机器学习基础2–python科学计算之numpy</a><br><a href="/2018/09/04/marchine-learning-base-pandas-01/">机器学习基础3–python科学计算pandas(上)</a><br><a href="/2018/09/05/marchine-learning-base-pandas-02/">机器学习基础4–python科学计算pandas(下)</a><br><a href="/2018/09/05/marchine-learning-base-matplotlib-01/">机器学习基础5–python画图库matplotlib(上）</a><br><a href="/2018/11/06/marchine-learning-base-matplotlib-02/">机器学习基础6–python画图库matplotlib(中）</a><br><a href="/2018/11/28/marchine-learning-base-matplotlib-03/">机器学习基础7–python画图库matplotlib(下）</a></p><h1 id="TensorFlow的安装"><a href="#TensorFlow的安装" class="headerlink" title="TensorFlow的安装"></a>TensorFlow的安装</h1><p>最详细的安装方法还是官网</p><p><a href="https://www.tensorflow.org/install/" target="_blank" rel="noopener">Install TensorFlow</a></p><p>建议安装 <a href="https://www.jetbrains.com/pycharm/download/" target="_blank" rel="noopener">Pycharm</a></p><p>然后在Preferences里面，找到Project Interpreter,然后点击+号，搜索tensorflow，点击安装之后，点击Apply。这样比较简单方便。</p><p><img src="/img/2018-12-04-tensorflow-introduction-01-02.png" alt></p><p>试一试，在Pycharm中新建一个工程，创建一个python文件，然后导入一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br></pre></td></tr></table></figure><p>如果没报错，那么说明安装成功！</p><p>下一篇我们梳理一下TensorFlow中的基础概念，并实现一个简单的线性回归。</p><p>Thx~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow是Google开发的一款神经网络的Python外部的结构包, 也是一个采用数据流图来进行数值计算的开源软件库.本篇我们介绍一下深度学习领域的基础知识。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://wangyeming.github.com/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础7--python画图库matplotlib(下）</title>
    <link href="http://wangyeming.github.com/2018/11/28/marchine-learning-base-matplotlib-03/"/>
    <id>http://wangyeming.github.com/2018/11/28/marchine-learning-base-matplotlib-03/</id>
    <published>2018-11-28T07:38:02.000Z</published>
    <updated>2019-09-09T12:30:06.611Z</updated>
    
    <content type="html"><![CDATA[<p>第一篇我们讲了matplot画图的基本要素，第二篇讲matplot若干个常见的基础图的画图操作。最后一篇我们讲一下matplot画图中可能会用到的几个高级用法。</p><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-09.gif" alt></p><a id="more"></a><h1 id="Subplot-多图合一"><a href="#Subplot-多图合一" class="headerlink" title="Subplot 多图合一"></a>Subplot 多图合一</h1><p>matplotlib 是可以组合许多的小图, 放在一张大图里面显示的. 使用到的方法叫作 subplot.</p><h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 创建小图，将整个图像窗口分为2行2列,当前位置为1</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])    <span class="comment"># 经过(0,1) (1, 1)画一条直线</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-01.png" alt></p><p>将这四个区域都填满：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)  <span class="comment"># 创建小图，将整个图像窗口分为2行2列,当前位置为1</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)  <span class="comment"># 当前位置为2</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">plt.subplot(<span class="number">223</span>)  <span class="comment"># 简写</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">3</span>])</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-02.png" alt></p><h2 id="非均匀分布"><a href="#非均匀分布" class="headerlink" title="非均匀分布"></a>非均匀分布</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 两行一列</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 两行三列,当前位置是4(因为该命令执行后，第一行重新变成三列，所以当前位置3+1=4)</span></span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">3</span>])</span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-03.png" alt></p><h2 id="分格"><a href="#分格" class="headerlink" title="分格"></a>分格</h2><h3 id="subplot2grid-方法"><a href="#subplot2grid-方法" class="headerlink" title="subplot2grid()方法"></a>subplot2grid()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()  <span class="comment"># 创建图像</span></span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>),  <span class="comment"># 三行三列</span></span><br><span class="line">                       (<span class="number">0</span>, <span class="number">0</span>),  <span class="comment"># 从第0行第0列开始作图</span></span><br><span class="line">                       colspan=<span class="number">3</span>  <span class="comment"># 跨度为3，一整行</span></span><br><span class="line">                       )</span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># 画小图</span></span><br><span class="line">ax1.set_title(<span class="string">'ax1_title'</span>)  <span class="comment"># 设置小图的标题</span></span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), colspan=<span class="number">2</span>)</span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), rowspan=<span class="number">2</span>)</span><br><span class="line">ax4 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">ax4.scatter([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">ax4.set_xlabel(<span class="string">'ax4_x'</span>)</span><br><span class="line">ax4.set_ylabel(<span class="string">'ax4_y'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-04.png" alt></p><h3 id="gridspec"><a href="#gridspec" class="headerlink" title="gridspec"></a>gridspec</h3><p>导入matplotlib.gridspec模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画布分为3x3</span></span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 第0行，跨整行</span></span><br><span class="line">ax6 = plt.subplot(gs[<span class="number">0</span>, :])</span><br><span class="line">ax7 = plt.subplot(gs[<span class="number">1</span>, :<span class="number">2</span>])</span><br><span class="line">ax8 = plt.subplot(gs[<span class="number">1</span>:, <span class="number">2</span>])</span><br><span class="line"><span class="comment"># -1表示倒数第一行</span></span><br><span class="line">ax9 = plt.subplot(gs[<span class="number">-1</span>, <span class="number">0</span>])</span><br><span class="line">ax10 = plt.subplot(gs[<span class="number">-1</span>, <span class="number">-2</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-05.png" alt></p><h3 id="subplots"><a href="#subplots" class="headerlink" title="subplots()"></a>subplots()</h3><p>借助subplots()方法，我们也可以分格显示图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="keyword">True</span>, sharey=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">ax11.scatter([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">plt.tight_layout()  <span class="comment"># 紧凑显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-06.png" alt></p><h1 id="plot-in-plot-图中图"><a href="#plot-in-plot-图中图" class="headerlink" title="plot in plot 图中图"></a>plot in plot 图中图</h1><p>matplot支持我们在同一个figure里面，画多个图。也就是图中图。</p><p>先画一个大图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 图中图</span></span><br><span class="line"><span class="comment"># 初始化figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画大图</span></span><br><span class="line"><span class="comment"># 确定大图左下角的位置以及宽高</span></span><br><span class="line">left, bottom, width, height = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 通过add_axes()方法，向figure里面添加第一个图</span></span><br><span class="line">ax1 = fig.add_axes([left, bottom, width, height])</span><br><span class="line">ax1.plot(x, y, <span class="string">'r'</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax1.set_title(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure><p>接着我们画左上角的小图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left, bottom, width, height = <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">0.25</span>, <span class="number">0.25</span></span><br><span class="line">ax2 = fig.add_axes([left, bottom, width, height])</span><br><span class="line">ax2.plot(y, x, <span class="string">'b'</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax2.set_title(<span class="string">'title inside 1'</span>)</span><br></pre></td></tr></table></figure><p>然后是右下角的小图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.axes([<span class="number">0.6</span>, <span class="number">0.2</span>, <span class="number">0.25</span>, <span class="number">0.25</span>])</span><br><span class="line">plt.plot(y[::<span class="number">-1</span>], x, <span class="string">'g'</span>)  <span class="comment"># 注意对y进行了逆序处理</span></span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">plt.title(<span class="string">'title inside 2'</span>)</span><br><span class="line"><span class="comment"># 展示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-07.png" alt></p><h1 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h1><p>matplot支持我们展示动画,首先我们需要导入animation模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>接下来我们定义一个0~2π内的正弦曲线</p><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-08.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fig, ax = plt.subplots()</span><br><span class="line"><span class="comment"># 0~2π内的正弦曲线</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">0.01</span>)</span><br><span class="line">line, = ax.plot(x, np.sin(x))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义动画</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(i)</span>:</span></span><br><span class="line">    line.set_ydata(np.sin(x + i / <span class="number">10.0</span>))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 帧函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    line.set_ydata(np.sin(x))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ani = animation.FuncAnimation(fig=fig,  <span class="comment"># 进行动画绘制的figure</span></span><br><span class="line">                              func=animate,  <span class="comment"># 自定义动画函数</span></span><br><span class="line">                              frames=<span class="number">100</span>,  <span class="comment"># 动画长度，一次循环包含的帧数</span></span><br><span class="line">                              init_func=init,  <span class="comment"># 自定义开始帧</span></span><br><span class="line">                              interval=<span class="number">20</span>,  <span class="comment"># 更新频率，以ms计</span></span><br><span class="line">                              blit=<span class="keyword">False</span>  <span class="comment"># 选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画</span></span><br><span class="line">                              )</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-28-marchine-learning-base-matplotlib-03-09.gif" alt></p><h2 id="保存为视频"><a href="#保存为视频" class="headerlink" title="保存为视频"></a>保存为视频</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ani.save(<span class="string">'basic_animation.mp4'</span>, fps=<span class="number">30</span>, extra_args=[<span class="string">'-vcodec'</span>, <span class="string">'libx264'</span>])</span><br></pre></td></tr></table></figure><p>当然，如果报错的话，记得安装一下ffmpeg或者mencoder,例如mac下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install ffmpeg</span><br></pre></td></tr></table></figure><h2 id="保存为gif图"><a href="#保存为gif图" class="headerlink" title="保存为gif图"></a>保存为gif图</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ani.save(<span class="string">'basic_animation.gif'</span>, writer=<span class="string">'imagemagick'</span>, fps=<span class="number">60</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一篇我们讲了matplot画图的基本要素，第二篇讲matplot若干个常见的基础图的画图操作。最后一篇我们讲一下matplot画图中可能会用到的几个高级用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2018-11-28-marchine-learning-base-matplotlib-03-09.gif&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="http://wangyeming.github.com/tags/python/"/>
    
      <category term="matplotlib" scheme="http://wangyeming.github.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>理解numpy中的meshgrid()方法</title>
    <link href="http://wangyeming.github.com/2018/11/12/numpy-meshgrid/"/>
    <id>http://wangyeming.github.com/2018/11/12/numpy-meshgrid/</id>
    <published>2018-11-12T09:00:22.000Z</published>
    <updated>2019-09-09T12:30:06.611Z</updated>
    
    <content type="html"><![CDATA[<p>python的meshgrid()方法在很多地方都有应用，例如生成等高线图的数据集。那meshgrid()方法的目的是什么呢？</p><p><img src="/img/2018-11-12-numpy-meshgrid-01.png" alt></p><a id="more"></a><p>借用一张图，</p><p><img src="/img/2018-11-12-numpy-meshgrid-01.png" alt></p><p>可以看到，meshgrid()方法接受两个一维向量，生成一个坐标矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">xvalues = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">yvalues = np.array([<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>])</span><br><span class="line"></span><br><span class="line">xx, yy = np.meshgrid(xvalues, yvalues)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'xx='</span>, xx)</span><br><span class="line">print(<span class="string">'yy='</span>, yy)</span><br></pre></td></tr></table></figure><p>输出</p><pre><code>xx= [[1 2 3 4]     [1 2 3 4]     [1 2 3 4]]yy= [[7 7 7 7]     [6 6 6 6]     [5 5 5 5]]</code></pre><p>将生成的两个坐标矩阵通过matplot库的plot()方法画出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(xx, yy, marker=<span class="string">'.'</span>, color=<span class="string">'k'</span>, linestyle=<span class="string">'none'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-12-numpy-meshgrid-02.png" alt></p><p>可以看到，通过meshgrid()方法，可以很简单的生成坐标矩阵。而坐标矩阵在图像绘制中有很多应用，例如我们画网格图：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sinus2d</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.sin(x) + np.sin(y)</span><br><span class="line"></span><br><span class="line">xx, yy = np.meshgrid(np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">10</span>), np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">10</span>))</span><br><span class="line">z = sinus2d(xx, yy)  <span class="comment"># Create the image on this grid</span></span><br><span class="line"></span><br><span class="line">plt.imshow(z, origin=<span class="string">'lower'</span>, interpolation=<span class="string">'none'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-12-numpy-meshgrid-03.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 增加坐标矩阵的密集程度</span></span><br><span class="line">xx, yy = np.meshgrid(np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">100</span>), np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">100</span>))</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-12-numpy-meshgrid-04.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;python的meshgrid()方法在很多地方都有应用，例如生成等高线图的数据集。那meshgrid()方法的目的是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2018-11-12-numpy-meshgrid-01.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="numpy" scheme="http://wangyeming.github.com/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>画图离不开色彩--说说matplot的cmap</title>
    <link href="http://wangyeming.github.com/2018/11/07/matplot-cmap/"/>
    <id>http://wangyeming.github.com/2018/11/07/matplot-cmap/</id>
    <published>2018-11-07T07:37:35.000Z</published>
    <updated>2019-09-09T12:30:06.611Z</updated>
    
    <content type="html"><![CDATA[<p>一张好看的图，离不开各种各样的颜色。在matplot中，有一个cmap的概念，通过cmap，我们可以很方便的给多组数据自动分配色彩，画出很好看的图。这篇文章就简单介绍下cmap的概念和用法。</p><p><img src="/img/2018-11-07-matplot-cmap-02.webp" alt></p><a id="more"></a><h2 id="cmap是什么"><a href="#cmap是什么" class="headerlink" title="cmap是什么"></a>cmap是什么</h2><p>cmap也就是colormap，可以理解为接受一个数值，输出一个指定的颜色的字典。下面这张图就展示了常见的一些cmap。</p><p><img src="/img/2018-11-07-matplot-cmap-01.webp" alt></p><p>可以点击<a href="https://matplotlib.org/examples/color/colormaps_reference.html" target="_blank" rel="noopener">matplot cmap</a>这里，里面有一个demo示例，会画一个包含matplot中所有cmap的图。</p><p>这里常见的cmap有：</p><p>纯色渐变系列：</p><p><img src="/img/2018-11-07-matplot-cmap-02.webp" alt></p><p>比如说画灰度图的话，可以选择Greys这个cmap。</p><h2 id="如何在画图中使用cmap"><a href="#如何在画图中使用cmap" class="headerlink" title="如何在画图中使用cmap"></a>如何在画图中使用cmap</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span>  <span class="comment"># data size</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)  <span class="comment"># 每一个点的X值,平均数是0，方差是1</span></span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)  <span class="comment"># 每一个点的Y值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们每个点的颜色和该点的X值+Y值的和相关</span></span><br><span class="line">color = X + Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用我们上面说的灰度图</span></span><br><span class="line">cmap = plt.get_cmap(<span class="string">'Greys'</span>)</span><br><span class="line"><span class="comment"># cmap = plt.cm.Greys #也可以这么写</span></span><br><span class="line"><span class="comment"># 利用normlize来标准化颜色的值</span></span><br><span class="line">norm = plt.Normalize(vmin=<span class="number">-3</span>, vmax=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, alpha=<span class="number">0.5</span>, c=color, cmap=cmap, norm=norm)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.xticks(())  <span class="comment"># ignore xticks</span></span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.yticks(())  <span class="comment"># ignore yticks</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-07-matplot-cmap-03.png" alt></p><p>其中，我们用到了matplotlib.colors.Normalize类，比如说我们的颜色对应的值取值范围在[-10, 10]之间和[-1,1]之间肯定是不能套用同一个转换标准的，通过Normalize标准化，我们可以很方便的将我们的实际值合适的分布到color map上。</p><p>我们讲colormap换成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmap = plt.get_cmap(<span class="string">'Spectral'</span>)</span><br></pre></td></tr></table></figure><p>画出来的图的颜色就是下面这样的：</p><p><img src="/img/2018-11-07-matplot-cmap-04.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一张好看的图，离不开各种各样的颜色。在matplot中，有一个cmap的概念，通过cmap，我们可以很方便的给多组数据自动分配色彩，画出很好看的图。这篇文章就简单介绍下cmap的概念和用法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2018-11-07-matplot-cmap-02.webp&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Matplot画图" scheme="http://wangyeming.github.com/categories/Matplot%E7%94%BB%E5%9B%BE/"/>
    
    
      <category term="matplotlib" scheme="http://wangyeming.github.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础6--python画图库matplotlib(中）</title>
    <link href="http://wangyeming.github.com/2018/11/06/marchine-learning-base-matplotlib-02/"/>
    <id>http://wangyeming.github.com/2018/11/06/marchine-learning-base-matplotlib-02/</id>
    <published>2018-11-06T01:41:23.000Z</published>
    <updated>2019-09-09T12:30:06.610Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲了matplot画图的基本要素，这篇讲matplot几个基础图的画图操作。</p><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-19.png" alt></p><a id="more"></a><h1 id="折线图Polyline"><a href="#折线图Polyline" class="headerlink" title="折线图Polyline"></a>折线图Polyline</h1><p>画折线图的方法是pyplot.plot(),返回 matplotlib.lines.Line2D 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x= np.linspace(<span class="number">0</span>, <span class="number">2</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># label的值可以作为图例默认的值展示</span></span><br><span class="line"></span><br><span class="line">plt.plot(x, x, label=<span class="string">'linear'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">2</span>, label=<span class="string">'quadratic'</span>)</span><br><span class="line">plt.plot(x, x**<span class="number">3</span>, label=<span class="string">'cubic'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'x label'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y label'</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">"Simple Plot"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-13.png" alt></p><p>进一步的，我们可以在一张图上绘制多个子图(即一张Figure上绘制多个Axes),此时我们借助的是pyplot.subplot()方法<br>这里我们画一个余弦函数，一个自定义函数，然后上下分布。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.exp(-t) * np.cos(<span class="number">2</span> * np.pi * t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.1</span>)</span><br><span class="line">t2 = np.arange(<span class="number">0.0</span>, <span class="number">5.0</span>, <span class="number">0.02</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">211</span>)  <span class="comment"># the same as plt.subplot(2, 1, 1)</span></span><br><span class="line">plt.plot(t1, f(t1), <span class="string">'bo'</span>, t2, f(t2), <span class="string">'k'</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(t2, np.cos(<span class="number">2</span> * np.pi * t2), <span class="string">'r--'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-14.png" alt></p><h1 id="散点图Scatter"><a href="#散点图Scatter" class="headerlink" title="散点图Scatter"></a>散点图Scatter</h1><p>画散点图的方法是pyplot.scatter(),返回 matplotlib.collections.PathCollection 对象,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span>  <span class="comment"># data size</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)  <span class="comment"># 每一个点的X值,平均数是0，方差是1</span></span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)  <span class="comment"># 每一个点的Y值</span></span><br><span class="line">T = np.arctan2(Y, X)  <span class="comment"># for color value</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line"><span class="comment"># s size，数字越大，点的面积就越大</span></span><br><span class="line"><span class="comment"># c color 颜色，有多种表达方式。</span></span><br><span class="line"><span class="comment"># aplha 透明度 0(完全透明)到1之间</span></span><br><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, c=T, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.xticks(())  <span class="comment"># ignore xticks</span></span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.yticks(())  <span class="comment"># ignore yticks</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-01.png" alt></p><p>其中关于颜色的设置这部分，我们先看下官方注释里面的表达方式：<br>    #           - A single color format string.<br>    #           - A sequence of color specifications of length n.<br>    #           - A sequence of n numbers to be mapped to colors using <em>cmap</em> and<br>    #             <em>norm</em>.<br>    #           - A 2-D array in which the rows are RGB or RGBA. </p><h2 id="颜色的表达方式"><a href="#颜色的表达方式" class="headerlink" title="颜色的表达方式"></a>颜色的表达方式</h2><h3 id="字符串表示法"><a href="#字符串表示法" class="headerlink" title="字符串表示法"></a>字符串表示法</h3><p>A single color format string.<br>字符串表示的颜色,比如说红色可以用’red’或者’r’表示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, c=<span class="string">'r'</span>, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h3 id="字符串序列表示法"><a href="#字符串序列表示法" class="headerlink" title="字符串序列表示法"></a>字符串序列表示法</h3><p>A sequence of color specifications of length n.<br>用一个长度为n的颜色序列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = [<span class="string">'red'</span>] * <span class="number">512</span> + [<span class="string">'blue'</span>] * <span class="number">512</span></span><br><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, c=T, alpha=<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure><h3 id="cmap表示法"><a href="#cmap表示法" class="headerlink" title="cmap表示法"></a>cmap表示法</h3><p>具体可以参考这篇文章 <a href="/2018/11/07/matplot-cmap/#more">画图离不开色彩–说说matplot的cmap</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span>  <span class="comment"># data size</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)  <span class="comment"># 每一个点的X值,平均数是0，方差是1</span></span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)  <span class="comment"># 每一个点的Y值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我们每个点的颜色和该点的X值+Y值的和相关</span></span><br><span class="line">color = X + Y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用名为Spectral的cmap</span></span><br><span class="line">cmap = plt.get_cmap(<span class="string">'Spectral'</span>)</span><br><span class="line"><span class="comment"># cmap = plt.cm.Spectral #也可以这么写</span></span><br><span class="line"><span class="comment"># 利用normlize来标准化颜色的值</span></span><br><span class="line">norm = plt.Normalize(vmin=<span class="number">-3</span>, vmax=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, alpha=<span class="number">0.5</span>, c=color, cmap=cmap, norm=norm)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.xticks(())  <span class="comment"># ignore xticks</span></span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.yticks(())  <span class="comment"># ignore yticks</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h3 id="RGB-RGBA二维数组表示法"><a href="#RGB-RGBA二维数组表示法" class="headerlink" title="RGB,RGBA二维数组表示法"></a>RGB,RGBA二维数组表示法</h3><p>很简单，和字符串表达方式类似，RGB或RGBA的表达方式可以表示的颜色更多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = [<span class="string">'#42A5F5'</span>] * <span class="number">512</span> + [<span class="string">'#FF5252'</span>] * <span class="number">512</span></span><br><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, c=T)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-02.png" alt></p><p>特别的，如果所有点都是同一个颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = [<span class="string">'#42A5F5'</span>]</span><br><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, c=T)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-03.png" alt></p><h1 id="柱状图Bar"><a href="#柱状图Bar" class="headerlink" title="柱状图Bar"></a>柱状图Bar</h1><p>画柱状图的方法是 pyplot.bar(),返回 matplot.container.BarContainer 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">12</span></span><br><span class="line">X = np.arange(n)</span><br><span class="line">Y1 = (<span class="number">1</span> - X / float(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line"><span class="comment"># facecolor柱子的填充色,edgecolor柱子的边缘色</span></span><br><span class="line">plt.bar(X, +Y1, facecolor=<span class="string">'#9999ff'</span>, edgecolor=<span class="string">'red'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-04.png" alt></p><p>更进一步，我们将两个柱状图上下叠放在一起，并标注上具体的数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">12</span></span><br><span class="line">X = np.arange(n)</span><br><span class="line">Y1 = (<span class="number">1</span> - X / float(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line">Y2 = (<span class="number">1</span> - X / float(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 柱状图</span></span><br><span class="line">plt.bar(X, +Y1, facecolor=<span class="string">'#9999ff'</span>, edgecolor=<span class="string">'white'</span>)</span><br><span class="line">plt.bar(X, -Y2, facecolor=<span class="string">'#ff9999'</span>, edgecolor=<span class="string">'white'</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-.5</span>, n)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.ylim(<span class="number">-1.25</span>, <span class="number">1.25</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文字</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y1):</span><br><span class="line">    <span class="comment"># ha: horizontal alignment</span></span><br><span class="line">    <span class="comment"># va: vertical alignment</span></span><br><span class="line">    plt.text(x, y + <span class="number">0.05</span>, <span class="string">'%.2f'</span> % y, ha=<span class="string">'center'</span>, va=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y2):</span><br><span class="line">    <span class="comment"># ha: horizontal alignment</span></span><br><span class="line">    <span class="comment"># va: vertical alignment</span></span><br><span class="line">    plt.text(x, -y - <span class="number">0.05</span>, <span class="string">'%.2f'</span> % y, ha=<span class="string">'center'</span>, va=<span class="string">'top'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-05.png" alt></p><h1 id="直方图Histogram"><a href="#直方图Histogram" class="headerlink" title="直方图Histogram"></a>直方图Histogram</h1><p>画柱状图的方法是 pyplot.hist(),返回 matplotlib.patches.Patch 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">19680801</span>)</span><br><span class="line"></span><br><span class="line">mu1, sigma1 = <span class="number">100</span>, <span class="number">15</span></span><br><span class="line">mu2, sigma2 = <span class="number">80</span>, <span class="number">15</span></span><br><span class="line">x1 = mu1 + sigma1 * np.random.randn(<span class="number">10000</span>)</span><br><span class="line">x2 = mu2 + sigma2 * np.random.randn(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># the histogram of the data</span></span><br><span class="line"><span class="comment"># 50：将数据分成50组</span></span><br><span class="line"><span class="comment"># facecolor：颜色；alpha：透明度</span></span><br><span class="line"><span class="comment"># density：是密度而不是具体数值</span></span><br><span class="line">n1, bins1, patches1 = plt.hist(x1, <span class="number">50</span>, density=<span class="keyword">True</span>, facecolor=<span class="string">'g'</span>, alpha=<span class="number">1</span>)</span><br><span class="line">n2, bins2, patches2 = plt.hist(x2, <span class="number">50</span>, density=<span class="keyword">True</span>, facecolor=<span class="string">'r'</span>, alpha=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># n：概率值；bins：具体数值；patches：直方图对象。</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">'Smarts'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Probability'</span>)</span><br><span class="line">plt.title(<span class="string">'Histogram of IQ'</span>)</span><br><span class="line"></span><br><span class="line">plt.text(<span class="number">110</span>, <span class="number">.025</span>, <span class="string">r'$\mu=100,\ \sigma=15$'</span>)</span><br><span class="line">plt.text(<span class="number">50</span>, <span class="number">.025</span>, <span class="string">r'$\mu=80,\ \sigma=15$'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x，y轴的具体范围</span></span><br><span class="line">plt.axis([<span class="number">40</span>, <span class="number">160</span>, <span class="number">0</span>, <span class="number">0.03</span>])</span><br><span class="line">plt.grid(<span class="keyword">True</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-15.png" alt></p><h1 id="饼状图Pie"><a href="#饼状图Pie" class="headerlink" title="饼状图Pie"></a>饼状图Pie</h1><p>画饼状图的方法是 pyplot.pie(),返回 matplotlib.patches.Wedge 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>, <span class="number">9</span>))</span><br><span class="line">labels = [<span class="string">u'TypeA'</span>, <span class="string">u'TypeB'</span>, <span class="string">u'TypeC'</span>, <span class="string">u'TypeD'</span>]  <span class="comment"># 定义标签</span></span><br><span class="line">values = [<span class="number">46</span>, <span class="number">253</span>, <span class="number">321</span>, <span class="number">66</span>]  <span class="comment"># 每块值</span></span><br><span class="line">colors = [<span class="string">'red'</span>, <span class="string">'yellowgreen'</span>, <span class="string">'lightskyblue'</span>, <span class="string">'yellow'</span>]  <span class="comment"># 每块颜色定义</span></span><br><span class="line">explode = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)  <span class="comment"># 将某一块分割出来，值越大分割出的间隙越大</span></span><br><span class="line">patches, text1, text2 = plt.pie(values,</span><br><span class="line">                                explode=explode,</span><br><span class="line">                                labels=labels,</span><br><span class="line">                                colors=colors,</span><br><span class="line">                                autopct=<span class="string">'%.2f%%'</span>,  <span class="comment"># 数值保留固定小数位</span></span><br><span class="line">                                shadow=<span class="keyword">False</span>,  <span class="comment"># 无阴影设置</span></span><br><span class="line">                                startangle=<span class="number">90</span>,  <span class="comment"># 逆时针起始角度设置</span></span><br><span class="line">                                pctdistance=<span class="number">0.6</span>)  <span class="comment"># 数值距圆心半径倍数距离</span></span><br><span class="line"><span class="comment"># patches饼图的返回值，texts1饼图外label的文本，texts2饼图内部的文本</span></span><br><span class="line"><span class="comment"># x，y轴刻度设置一致，保证饼图为圆形</span></span><br><span class="line">plt.axis(<span class="string">'equal'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="调整饼的偏离值"><a href="#调整饼的偏离值" class="headerlink" title="调整饼的偏离值"></a>调整饼的偏离值</h2><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-09.png" alt></p><p>首先我们看explode参数，explode接受一个长度=值数量的数组，数组中的值的含义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正值表示向外偏离</span></span><br><span class="line">explode = (<span class="number">0.3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-10.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 副值表示向外偏离</span></span><br><span class="line">explode = (<span class="number">-0.3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-11.png" alt></p><h2 id="标注字符串的格式化"><a href="#标注字符串的格式化" class="headerlink" title="标注字符串的格式化"></a>标注字符串的格式化</h2><p>autopct参数可以接受None(默认)，字符串或者函数。如果是一个字符串，则按照<code>fmt%pct</code>的方式格式化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 表示%分数表示，并保留两位小数</span></span><br><span class="line">autopct=<span class="string">'%.2f%%'</span></span><br></pre></td></tr></table></figure><p>如果是函数的话，可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回值是一个函数，该函数接受一个值，返回一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_autopct</span><span class="params">(values)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">my_autopct</span><span class="params">(pct)</span>:</span></span><br><span class="line">        total = sum(values)</span><br><span class="line">        val = int(round(pct * total / <span class="number">100.0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;p:.2f&#125;% \n (&#123;v:d&#125;)'</span>.format(p=pct, v=val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> my_autopct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用的时候这样</span></span><br><span class="line">autopct=make_autopct(values)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-12.png" alt></p><h1 id="等高线图Contours"><a href="#等高线图Contours" class="headerlink" title="等高线图Contours"></a>等高线图Contours</h1><p>画等高线用的是plt.contour(),返回 matplot.contour.QuadContourSet 对象</p><p>首先我们需要了解，等高线图的数据和前面散点图和柱状图的二维数据结构不一样，多了一个维度：高度。也就是说，等高线图的数据集是由(x,y,h)这个三维点构成。</p><p>生成数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据x,y生成高度值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="comment"># the height function</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - x / <span class="number">2</span> + x ** <span class="number">5</span> + y ** <span class="number">3</span>) * np.exp(-x ** <span class="number">2</span> - y ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, n)</span><br><span class="line">y = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, n)</span><br><span class="line"><span class="comment"># 通过meshgrid()方法得到坐标矩阵</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br></pre></td></tr></table></figure><h2 id="等高线间区域填充"><a href="#等高线间区域填充" class="headerlink" title="等高线间区域填充"></a>等高线间区域填充</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plt.contourf()函数进行颜色填充, </span></span><br><span class="line">plt.contourf(X, Y, f(X, Y), <span class="number">8</span>, alpha=<span class="number">.75</span>, cmap=plt.cm.hot)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-06.png" alt></p><h2 id="画等高线"><a href="#画等高线" class="headerlink" title="画等高线"></a>画等高线</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 绘制等高线</span></span><br><span class="line">C = plt.contour(X, Y, f(X, Y), <span class="number">8</span>, colors=<span class="string">'black'</span>, linewidth=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-07.png" alt></p><h2 id="等高线的标注"><a href="#等高线的标注" class="headerlink" title="等高线的标注"></a>等高线的标注</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#inline表示Label画在线内</span></span><br><span class="line">plt.clabel(C, inline=<span class="keyword">True</span>, fontsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-08.png" alt></p><h1 id="三维图"><a href="#三维图" class="headerlink" title="三维图"></a>三维图</h1><h2 id="绘制三维坐标轴空间"><a href="#绘制三维坐标轴空间" class="headerlink" title="绘制三维坐标轴空间"></a>绘制三维坐标轴空间</h2><p>首先需要导入mpl_toolkits.mplot3d包中的Axes3D</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br></pre></td></tr></table></figure><p>创建Figure对象，并用Axes3D画三维坐标轴</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-16.png" alt></p><h2 id="3D散点图"><a href="#3D散点图" class="headerlink" title="3D散点图"></a>3D散点图</h2><p>同样的，我们可以在三维坐标系中画散点图，区别只是数据有三个维度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randint(<span class="number">0</span>, <span class="number">255</span>, size=[<span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>])</span><br><span class="line">x, y, z = data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>]</span><br><span class="line">ax.scatter(x[:<span class="number">10</span>], y[:<span class="number">10</span>], z[:<span class="number">10</span>], c=<span class="string">'r'</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-17.png" alt></p><h2 id="3D平面图"><a href="#3D平面图" class="headerlink" title="3D平面图"></a>3D平面图</h2><p>画三维平面图用到的是Axes3D.plot_surface()方法，该方法创建 mpl_toolkits_mlplot3d_art3d.Poly3DCollection 对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X = np.arange(<span class="number">-4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line">Y = np.arange(<span class="number">-4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line">X, Y = np.meshgrid(X, Y)  <span class="comment"># x-y 平面的网格</span></span><br><span class="line">R = np.sqrt(X ** <span class="number">2</span> + Y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment"># height value</span></span><br><span class="line">Z = np.sin(R)</span><br><span class="line"><span class="comment"># # rstride代表行的跨度，cstride代表列的跨度</span></span><br><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">5</span>, cstride=<span class="number">5</span>, cmap=plt.get_cmap(<span class="string">'rainbow'</span>))</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-18.png" alt></p><p>将跨度改成1，再看效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, cmap=plt.get_cmap(<span class="string">'rainbow'</span>))</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-19.png" alt></p><p>zdir可选择的值有x,y,z,选择z相当于投影到XY平面，同样的，选择x相当于投影到YZ平面，选择y相当于投影到XZ平面。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.contourf(X, Y, Z, zdir=<span class="string">'z'</span>, offset=<span class="number">-2</span>, cmap=plt.get_cmap(<span class="string">'rainbow'</span>))</span><br></pre></td></tr></table></figure><p><img src="/img/2018-11-06-marchine-learning-base-matplotlib-02-20.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇讲了matplot画图的基本要素，这篇讲matplot几个基础图的画图操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2018-11-06-marchine-learning-base-matplotlib-02-19.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="http://wangyeming.github.com/tags/python/"/>
    
      <category term="matplotlib" scheme="http://wangyeming.github.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础5--python画图库matplotlib(上）</title>
    <link href="http://wangyeming.github.com/2018/09/05/marchine-learning-base-matplotlib-01/"/>
    <id>http://wangyeming.github.com/2018/09/05/marchine-learning-base-matplotlib-01/</id>
    <published>2018-09-05T10:30:24.000Z</published>
    <updated>2019-09-09T12:30:06.609Z</updated>
    
    <content type="html"><![CDATA[<p>图像是我们最直观的数据表达方式，python的matplotlib库可以用来画图。下面来简单总结下matplotlib的使用方法。</p><p><img src="/img/2018-09-05-marchine-learning-base-matplotlib-01-05.png" alt></p><a id="more"></a><p>上篇讲matplot画图中用到的基础对象，包括<strong>图像Figure</strong>，<strong>平面曲线Line2D</strong>，<strong>坐标轴Axes</strong>，<strong>图例Legend</strong>, <strong>注解Annotation</strong>, <strong>注释Text</strong></p><p>理解这些对象，有利于我们更好的用matplot画图。</p><h1 id="matplotlib-导入"><a href="#matplotlib-导入" class="headerlink" title="matplotlib 导入"></a>matplotlib 导入</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><h1 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line"><span class="comment"># 创建图像</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># plot(x,y)画(x,y)曲线</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line"><span class="comment"># 显示图像</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-09-05-marchine-learning-base-matplotlib-01-01.png" alt></p><h1 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h1><h2 id="图像Figure"><a href="#图像Figure" class="headerlink" title="图像Figure"></a>图像Figure</h2><p>matplot中，图像对应的定义类是matplotlib.figure.Figure</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># num 标识编号，figsize 8英寸*5英寸，dpi图像的dp密度,facecolor背景色白色，edgecolor背景色白色</span></span><br><span class="line">plt.figure(num=<span class="number">1</span>, figsize=(<span class="number">8</span>,<span class="number">5</span>), dpi=<span class="number">100</span>, facecolor=<span class="string">'w'</span>, edgecolor=<span class="string">'w'</span>)</span><br></pre></td></tr></table></figure><p>plt.figure()创建了图像,并返回matplotlib.figure.Figure对象，这里我们选择隐式处理返回的对象。</p><h2 id="平面曲线Line2D"><a href="#平面曲线Line2D" class="headerlink" title="平面曲线Line2D"></a>平面曲线Line2D</h2><p>通过plot()方法创建matplotlib.line.Line2D对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定曲线的颜色，线的宽度，线的样式。</span></span><br><span class="line">plt.plot(x, y1, color=<span class="string">'red'</span>, linewidth=<span class="number">1.0</span>, linestyle=<span class="string">'--'</span>)</span><br><span class="line"><span class="comment"># 添加多条曲线</span></span><br><span class="line">plt.plot(x, y2)</span><br></pre></td></tr></table></figure><p>具体的参数可以在matplotlib.pyplot.Line2D的初始化函数里找到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, xdata, ydata,</span></span></span><br><span class="line"><span class="function"><span class="params">             linewidth=None,  # all Nones default to rc</span></span></span><br><span class="line"><span class="function"><span class="params">             linestyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             color=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             marker=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             markersize=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             markeredgewidth=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             markeredgecolor=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             markerfacecolor=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             markerfacecoloralt=<span class="string">'none'</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             fillstyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             antialiased=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             dash_capstyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             solid_capstyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             dash_joinstyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             solid_joinstyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             pickradius=<span class="number">5</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             drawstyle=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             markevery=None,</span></span></span><br><span class="line"><span class="function"><span class="params">             **kwargs</span></span></span><br><span class="line"><span class="function"><span class="params">             )</span>:</span></span><br></pre></td></tr></table></figure><h2 id="坐标轴Axes"><a href="#坐标轴Axes" class="headerlink" title="坐标轴Axes"></a>坐标轴Axes</h2><p>坐标轴的定义类是matplotlib.Axes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># xlim()和ylim()设置坐标轴范围</span></span><br><span class="line">plt.xlim((<span class="number">-1</span>, <span class="number">2</span>))</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># xlabel()和ylabel()设置坐标轴名称</span></span><br><span class="line">plt.xlabel(<span class="string">'X'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Y'</span>)</span><br><span class="line"><span class="comment"># 借助numpy的linspace()方法，设置更复杂的坐标，-1到2，总共5个坐标点</span></span><br><span class="line">new_ticks = np.linspace(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">plt.xticks(new_ticks)</span><br><span class="line"><span class="comment"># 也可以指定具体的点和标签值</span></span><br><span class="line">plt.yticks(ticket=[<span class="number">-2</span>, <span class="number">-1.8</span>, <span class="number">-1</span>, <span class="number">1.22</span>, <span class="number">3</span>],labels=[<span class="string">r'$really\ bad$'</span>, <span class="string">r'$bad$'</span>, <span class="string">r'$normal$'</span>, <span class="string">r'$good$'</span>, <span class="string">r'$really\ good$'</span>])</span><br></pre></td></tr></table></figure><p><img src="/img/2018-09-05-marchine-learning-base-matplotlib-01-02.png" alt></p><p>我们可以看到，这里二维图像默认的坐标轴有四条(上下左右)</p><p>更复杂的坐标轴设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取坐标轴实例</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 隐藏右边和上面的坐标轴</span></span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-09-05-marchine-learning-base-matplotlib-01-03.png" alt></p><p>调整坐标轴上刻度的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 值可以选择top，bottom，both，default，none</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br></pre></td></tr></table></figure><p>默认的坐标轴之间的连接处类似于矩形，我们可以调整坐标轴之间连接处具体的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># spines指定修改的是哪一条坐标轴,set_position()有好几个重载方法，这里用到的是set_position(self, position),，其中position参数是一个二维tuple。</span></span><br><span class="line"><span class="comment"># 第一个值是type,可选的type有"outward","axes","data".</span></span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'outward'</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>『outward』数组的第二个值是个数值，0的话，x轴与y轴的焦点正好在y轴最底部，如果n&gt;0，相当于向y轴负方向移动距离n。<br>『axes』  数组的第二个值取值范围0.0-1.0,表示将端点放在坐标轴的指定比例的位置<br>『data』  数组的第二个值就是坐标轴上具体的位置</p><h2 id="图例Legend"><a href="#图例Legend" class="headerlink" title="图例Legend"></a>图例Legend</h2><p>图例对应着的是 matplot.legend类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 图例的话，需要先通过plot()方法创建Line2D对象</span></span><br><span class="line">l1, = plt.plot(x, y1, label=<span class="string">'linear line'</span>)</span><br><span class="line">l2, = plt.plot(x, y2, color=<span class="string">'red'</span>, linewidth=<span class="number">1.0</span>, linestyle=<span class="string">'--'</span>, label=<span class="string">'square line'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># loc指定位置，如图例放在右上角就是loc='upper right', 'best'表示自动分配最佳位置，label表示图例的名称</span></span><br><span class="line">plt.legend(handles=[l1, l2], labels=[<span class="string">'up'</span>, <span class="string">'down'</span>], loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure><p><img src="/img/2018-09-05-marchine-learning-base-matplotlib-01-04.png" alt></p><h2 id="注解Annotation"><a href="#注解Annotation" class="headerlink" title="注解Annotation"></a>注解Annotation</h2><p>注解对应着的是 matplot.text.Annotation</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.annotate(<span class="string">r'$2x+1=%s$'</span> % y0,</span><br><span class="line">             xy=(x0, y0),               <span class="comment"># 对(1,3)这个点的描述</span></span><br><span class="line">             xycoords=<span class="string">'data'</span>,           <span class="comment"># 基于数据的值来选位置</span></span><br><span class="line">             xytext=(+<span class="number">30</span>, <span class="number">-30</span>),         <span class="comment"># xytext=(+30, -30)表示xy偏差值,</span></span><br><span class="line">             textcoords=<span class="string">'offset points'</span>,<span class="comment"># 对标注位置的描述</span></span><br><span class="line">             fontsize=<span class="number">16</span>,</span><br><span class="line">             arrowprops=dict(           <span class="comment"># 对箭头类型的设置</span></span><br><span class="line">                 arrowstyle=<span class="string">'-&gt;'</span>,</span><br><span class="line">                 connectionstyle=<span class="string">"arc3,rad=.2"</span>)</span><br></pre></td></tr></table></figure><h2 id="注释Text"><a href="#注释Text" class="headerlink" title="注释Text"></a>注释Text</h2><p>注释对应的定义类是 matplot.text.Text</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.text(x=<span class="number">-3.7</span>,</span><br><span class="line">        y=<span class="number">3</span>, </span><br><span class="line">        s=<span class="string">r'$This\ is\ the\ some\ text. \mu\ \sigma_i\ \alpha_t$'</span>,</span><br><span class="line">        fontdict=&#123;</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span>, </span><br><span class="line">            <span class="string">'color'</span>: <span class="string">'r'</span></span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>通过上面的注释和注解，我们再补充一条线段，一个点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 画虚线</span></span><br><span class="line">plt.plot([x0, x0, ], [<span class="number">0</span>, y0, ], <span class="string">'k--'</span>, linewidth=<span class="number">2.5</span>)</span><br><span class="line"><span class="comment"># 画点</span></span><br><span class="line">plt.scatter([x0, ], [y0, ], s=<span class="number">50</span>, color=<span class="string">'b'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/img/2018-09-05-marchine-learning-base-matplotlib-01-05.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;图像是我们最直观的数据表达方式，python的matplotlib库可以用来画图。下面来简单总结下matplotlib的使用方法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2018-09-05-marchine-learning-base-matplotlib-01-05.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="http://wangyeming.github.com/tags/python/"/>
    
      <category term="matplotlib" scheme="http://wangyeming.github.com/tags/matplotlib/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础4--python科学计算pandas(下)</title>
    <link href="http://wangyeming.github.com/2018/09/05/marchine-learning-base-pandas-02/"/>
    <id>http://wangyeming.github.com/2018/09/05/marchine-learning-base-pandas-02/</id>
    <published>2018-09-05T10:29:44.000Z</published>
    <updated>2019-09-09T12:30:06.610Z</updated>
    
    <content type="html"><![CDATA[<p>利用python进行科学计算，numpy和pandas这两个库是必不可少的。</p><p>上一篇介绍了pandas库的Series和DataFrame，以及DataFrame的基本方法，这篇的数据导入导出，数据合并等，</p><a id="more"></a><h1 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h1><p>pandas可以读取与存取的资料格式有很多种，像csv、excel、json、html与pickle等</p><p>这里是官方文档：<a href="http://pandas.pydata.org/pandas-docs/stable/io.html" target="_blank" rel="noopener">pandas IO Tools</a></p><p><img src="/img/2018-09-05-marchine-learning-base-pandas-02-01.png" alt></p><h1 id="合并concat"><a href="#合并concat" class="headerlink" title="合并concat"></a>合并concat</h1><p>使用pandas的DataFrame时，常常需要进行合并操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axis=0进行横向合并，axis=1进行纵向合并</span></span><br><span class="line">res = pd.concat([df1, df2, df3], axis=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 1  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 2  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 0  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 1  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 2  2.0  2.0  2.0  2.0</span></span><br></pre></td></tr></table></figure><p>可以发现，index此时还是按照每个df之前的值，如果想重置index，设置ignore_index=True即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># axis=0进行横向合并，axis=1进行纵向合并</span></span><br><span class="line">res = pd.concat([df1, df2, df3], axis=<span class="number">0</span>, ignore_index=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 5  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 6  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 7  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 8  2.0  2.0  2.0  2.0</span></span><br></pre></td></tr></table></figure><p>index恢复正常。</p><p>前面我们合并的数据集的列名完全相同，所以合并后的列数不变。如果合并的数据集的列并不完全相同呢？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#纵向"外"合并df1与df2,join的默认参数就是outer,outer的规则是</span></span><br><span class="line"><span class="comment">#依照column来做纵向合并，有相同的column上下合并在一起，其他独自的column个自成列，原本没有值的位置皆以NaN填充。</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'outer'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d    e</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment"># 3  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment"># 2  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 3  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  NaN  1.0  1.0  1.0  1.0</span></span><br></pre></td></tr></table></figure><p>如果join的值设置为inner，那么只有相同的column合并在一起，其他的会被抛弃。</p><h1 id="append添加数据"><a href="#append添加数据" class="headerlink" title="append添加数据"></a>append添加数据</h1><p>append方法可以将一个数据集添加到另一个数据集的下方，也就是纵向合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.append(df2, ignore_index=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><h1 id="多key合并merge"><a href="#多key合并merge" class="headerlink" title="多key合并merge"></a>多key合并merge</h1><p>merge方法与concat方法类似，但merge可以用于有两列作为key的数据。先看只有一组key列的情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                             <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                             <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                              <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                              <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line"><span class="comment">#    A   B key</span></span><br><span class="line"><span class="comment"># 0  A0  B0  K0</span></span><br><span class="line"><span class="comment"># 1  A1  B1  K1</span></span><br><span class="line"><span class="comment"># 2  A2  B2  K2</span></span><br><span class="line"><span class="comment"># 3  A3  B3  K3</span></span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line"><span class="comment">#    C   D key</span></span><br><span class="line"><span class="comment"># 0  C0  D0  K0</span></span><br><span class="line"><span class="comment"># 1  C1  D1  K1</span></span><br><span class="line"><span class="comment"># 2  C2  D2  K2</span></span><br><span class="line"><span class="comment"># 3  C3  D3  K3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#依据key column合并，并打印出</span></span><br><span class="line">res = pd.merge(left, right, on=<span class="string">'key'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">     A   B key   C   D</span><br><span class="line"><span class="comment"># 0  A0  B0  K0  C0  D0</span></span><br><span class="line"><span class="comment"># 1  A1  B1  K1  C1  D1</span></span><br><span class="line"><span class="comment"># 2  A2  B2  K2  C2  D2</span></span><br><span class="line"><span class="comment"># 3  A3  B3  K3  C3  D3</span></span><br></pre></td></tr></table></figure><p>接下来我们定义有两列作为key的合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                      <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>],</span><br><span class="line">                      <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                      <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                       <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>],</span><br><span class="line">                       <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                       <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line"><span class="comment">#    A   B key1 key2</span></span><br><span class="line"><span class="comment"># 0  A0  B0   K0   K0</span></span><br><span class="line"><span class="comment"># 1  A1  B1   K0   K1</span></span><br><span class="line"><span class="comment"># 2  A2  B2   K1   K0</span></span><br><span class="line"><span class="comment"># 3  A3  B3   K2   K1</span></span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line"><span class="comment">#    C   D key1 key2</span></span><br><span class="line"><span class="comment"># 0  C0  D0   K0   K0</span></span><br><span class="line"><span class="comment"># 1  C1  D1   K1   K0</span></span><br><span class="line"><span class="comment"># 2  C2  D2   K1   K0</span></span><br><span class="line"><span class="comment"># 3  C3  D3   K2   K0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#依据key1与key2 columns进行合并，并打印出四种结果['left', 'right', 'outer', 'inner']</span></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#    A   B key1 key2   C   D</span></span><br><span class="line"><span class="comment"># 0  A0  B0   K0   K0  C0  D0</span></span><br><span class="line"><span class="comment"># 1  A2  B2   K1   K0  C1  D1</span></span><br><span class="line"><span class="comment"># 2  A2  B2   K1   K0  C2  D2</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     A    B key1 key2    C    D</span></span><br><span class="line"><span class="comment"># 0   A0   B0   K0   K0   C0   D0</span></span><br><span class="line"><span class="comment"># 1   A1   B1   K0   K1  NaN  NaN</span></span><br><span class="line"><span class="comment"># 2   A2   B2   K1   K0   C1   D1</span></span><br><span class="line"><span class="comment"># 3   A2   B2   K1   K0   C2   D2</span></span><br><span class="line"><span class="comment"># 4   A3   B3   K2   K1  NaN  NaN</span></span><br><span class="line"><span class="comment"># 5  NaN  NaN   K2   K0   C3   D3</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'left'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#    A   B key1 key2    C    D</span></span><br><span class="line"><span class="comment"># 0  A0  B0   K0   K0   C0   D0</span></span><br><span class="line"><span class="comment"># 1  A1  B1   K0   K1  NaN  NaN</span></span><br><span class="line"><span class="comment"># 2  A2  B2   K1   K0   C1   D1</span></span><br><span class="line"><span class="comment"># 3  A2  B2   K1   K0   C2   D2</span></span><br><span class="line"><span class="comment"># 4  A3  B3   K2   K1  NaN  NaN</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'right'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     A    B key1 key2   C   D</span></span><br><span class="line"><span class="comment"># 0   A0   B0   K0   K0  C0  D0</span></span><br><span class="line"><span class="comment"># 1   A2   B2   K1   K0  C1  D1</span></span><br><span class="line"><span class="comment"># 2   A2   B2   K1   K0  C2  D2</span></span><br><span class="line"><span class="comment"># 3  NaN  NaN   K2   K0  C3  D3</span></span><br></pre></td></tr></table></figure><p>indicator=True会将合并的记录放在新的一列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>], <span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(df1)</span><br><span class="line"><span class="comment">#   col1 col_left</span></span><br><span class="line"><span class="comment"># 0     0        a</span></span><br><span class="line"><span class="comment"># 1     1        b</span></span><br><span class="line"></span><br><span class="line">print(df2)</span><br><span class="line"><span class="comment">#   col1  col_right</span></span><br><span class="line"><span class="comment"># 0     1          2</span></span><br><span class="line"><span class="comment"># 1     2          2</span></span><br><span class="line"><span class="comment"># 2     2          2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据col1进行合并，并启用indicator=True，最后打印出</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="keyword">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#   col1 col_left  col_right      _merge</span></span><br><span class="line"><span class="comment"># 0   0.0        a        NaN   left_only</span></span><br><span class="line"><span class="comment"># 1   1.0        b        2.0        both</span></span><br><span class="line"><span class="comment"># 2   2.0      NaN        2.0  right_only</span></span><br><span class="line"><span class="comment"># 3   2.0      NaN        2.0  right_only</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定indicator column的名称，并打印出</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="string">'indicator_column'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#   col1 col_left  col_right indicator_column</span></span><br><span class="line"><span class="comment"># 0   0.0        a        NaN        left_only</span></span><br><span class="line"><span class="comment"># 1   1.0        b        2.0             both</span></span><br><span class="line"><span class="comment"># 2   2.0      NaN        2.0       right_only</span></span><br><span class="line"><span class="comment"># 3   2.0      NaN        2.0       right_only</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用python进行科学计算，numpy和pandas这两个库是必不可少的。&lt;/p&gt;
&lt;p&gt;上一篇介绍了pandas库的Series和DataFrame，以及DataFrame的基本方法，这篇的数据导入导出，数据合并等，&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="http://wangyeming.github.com/tags/python/"/>
    
      <category term="pandas" scheme="http://wangyeming.github.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础3--python科学计算pandas(上)</title>
    <link href="http://wangyeming.github.com/2018/09/04/marchine-learning-base-pandas-01/"/>
    <id>http://wangyeming.github.com/2018/09/04/marchine-learning-base-pandas-01/</id>
    <published>2018-09-04T12:37:12.000Z</published>
    <updated>2019-09-09T12:30:06.609Z</updated>
    
    <content type="html"><![CDATA[<p>利用python进行科学计算，numpy和pandas这两个库是必不可少的。</p><p>上一篇介绍了numpy，本篇介绍pandas</p><a id="more"></a><p>如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。</p><p>要使用pandas，首先需要了解他主要两个数据结构：Series和DataFrame。</p><h1 id="pandas-导入"><a href="#pandas-导入" class="headerlink" title="pandas 导入"></a>pandas 导入</h1><p>省略下载和安装，代码中导入pandas</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> nupandaspy <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure><h1 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0     1.0</span></span><br><span class="line"><span class="string">1     3.0</span></span><br><span class="line"><span class="string">2     6.0</span></span><br><span class="line"><span class="string">3     NaN</span></span><br><span class="line"><span class="string">4    44.0</span></span><br><span class="line"><span class="string">5     1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>打印的内容，左边是索引，右边的值。由于我们没有为数据指定索引。于是会自动创建一个0到N-1（N为长度）的整数型索引.</p><h1 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h1><p>DataFrame是一个表格型的数据结构.它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。DataFrame既有行索引也有列索引， 它可以被看做由Series组成的大字典。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里我们用map字典结构去初始化一个DataFrame</span></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span>: <span class="number">1.</span>,</span><br><span class="line">                    <span class="string">'B'</span>: pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">                    <span class="string">'C'</span>: pd.Series(<span class="number">1</span>, index=list(range(<span class="number">4</span>)), dtype=<span class="string">'float32'</span>),</span><br><span class="line">                    <span class="string">'D'</span>: np.array([<span class="number">3</span>] * <span class="number">4</span>, dtype=<span class="string">'int32'</span>),</span><br><span class="line">                    <span class="string">'E'</span>: pd.Categorical([<span class="string">"test"</span>, <span class="string">"train"</span>, <span class="string">"test"</span>, <span class="string">"train"</span>]),</span><br><span class="line">                    <span class="string">'F'</span>: <span class="string">'foo'</span>&#125;)</span><br></pre></td></tr></table></figure><p>让我们分别看一下输出</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="打印DataFrame"><a href="#打印DataFrame" class="headerlink" title="打印DataFrame"></a>打印DataFrame</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2)</span><br></pre></td></tr></table></figure><pre><code>     A          B    C  D      E    F0  1.0 2013-01-02  1.0  3   test  foo1  1.0 2013-01-02  1.0  3  train  foo2  1.0 2013-01-02  1.0  3   test  foo3  1.0 2013-01-02  1.0  3  train  foo</code></pre><h3 id="查询每一列的type"><a href="#查询每一列的type" class="headerlink" title="查询每一列的type"></a>查询每一列的type</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2.dtypes)</span><br></pre></td></tr></table></figure><pre><code>A           float64B    datetime64[ns]C           float32D             int32E          categoryF            objectdtype: object</code></pre><h3 id="查看行号"><a href="#查看行号" class="headerlink" title="查看行号"></a>查看行号</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br></pre></td></tr></table></figure><pre><code>Int64Index([0, 1, 2, 3], dtype=&apos;int64&apos;)</code></pre><h3 id="查看列的名称"><a href="#查看列的名称" class="headerlink" title="查看列的名称"></a>查看列的名称</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br></pre></td></tr></table></figure><pre><code>Index([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;], dtype=&apos;object&apos;)</code></pre><h3 id="只查看值"><a href="#只查看值" class="headerlink" title="只查看值"></a>只查看值</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2.values)</span><br></pre></td></tr></table></figure><pre><code>[[1.0 Timestamp(&apos;2013-01-02 00:00:00&apos;) 1.0 3 &apos;test&apos; &apos;foo&apos;][1.0 Timestamp(&apos;2013-01-02 00:00:00&apos;) 1.0 3 &apos;train&apos; &apos;foo&apos;][1.0 Timestamp(&apos;2013-01-02 00:00:00&apos;) 1.0 3 &apos;test&apos; &apos;foo&apos;][1.0 Timestamp(&apos;2013-01-02 00:00:00&apos;) 1.0 3 &apos;train&apos; &apos;foo&apos;]]</code></pre><h3 id="查看描述"><a href="#查看描述" class="headerlink" title="查看描述"></a>查看描述</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2.describe())</span><br></pre></td></tr></table></figure><pre><code>         A    C    Dcount  4.0  4.0  4.0mean   1.0  1.0  3.0std    0.0  0.0  0.0min    1.0  1.0  3.025%    1.0  1.0  3.050%    1.0  1.0  3.075%    1.0  1.0  3.0max    1.0  1.0  3.0</code></pre><h3 id="转置"><a href="#转置" class="headerlink" title="转置"></a>转置</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2.T)</span><br></pre></td></tr></table></figure><p>这里输出就省略了</p><h3 id="索引排序"><a href="#索引排序" class="headerlink" title="索引排序"></a>索引排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#axis=0按照列名排序，axis=1按照行名排序 按照降序排序</span></span><br><span class="line">print(df2.sort_index(axis=<span class="number">1</span>, ascending=<span class="keyword">False</span>))</span><br></pre></td></tr></table></figure><pre><code>     F      E  D    C          B    A0  foo   test  3  1.0 2013-01-02  1.01  foo  train  3  1.0 2013-01-02  1.02  foo   test  3  1.0 2013-01-02  1.03  foo  train  3  1.0 2013-01-02  1.0</code></pre><h3 id="值排序"><a href="#值排序" class="headerlink" title="值排序"></a>值排序</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定按照某个列名排序</span></span><br><span class="line">print(df2.sort_values(by=<span class="string">'B'</span>))</span><br></pre></td></tr></table></figure><h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><p>首先我们新建一个DataFrame数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br></pre></td></tr></table></figure><p>“””<br>             A   B   C   D<br>2013-01-01   0   1   2   3<br>2013-01-02   4   5   6   7<br>2013-01-03   8   9  10  11<br>2013-01-04  12  13  14  15<br>2013-01-05  16  17  18  19<br>2013-01-06  20  21  22  23<br>“””</p><h3 id="指定筛选具体的列名"><a href="#指定筛选具体的列名" class="headerlink" title="指定筛选具体的列名"></a>指定筛选具体的列名</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="string">'A'</span>])  <span class="comment"># 类似map中通过key取值</span></span><br><span class="line">print(df.A)     <span class="comment"># 类似A是df的一个属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出都是一样的，会输出行名为『A』的列及行名</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2013-01-01     0</span></span><br><span class="line"><span class="string">2013-01-02     4</span></span><br><span class="line"><span class="string">2013-01-03     8</span></span><br><span class="line"><span class="string">2013-01-04    12</span></span><br><span class="line"><span class="string">2013-01-05    16</span></span><br><span class="line"><span class="string">2013-01-06    20</span></span><br><span class="line"><span class="string">Freq: D, Name: A, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="筛选多行or多列"><a href="#筛选多行or多列" class="headerlink" title="筛选多行or多列"></a>筛选多行or多列</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment">#输出0，1，2三行，这里的[0:3]不包括第3行,例如df[1:1]返回的就是一个空对象</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A  B   C   D</span></span><br><span class="line"><span class="string">2013-01-01  0  1   2   3</span></span><br><span class="line"><span class="string">2013-01-02  4  5   6   7</span></span><br><span class="line"><span class="string">2013-01-03  8  9  10  11</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样写相当于一个闭区间</span></span><br><span class="line">print(df[<span class="string">'20130102'</span>:<span class="string">'20130104'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-02   4   5   6   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9  10  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="通过判断"><a href="#通过判断" class="headerlink" title="通过判断"></a>通过判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df[df.A&gt;<span class="number">8</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17  18  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="根据标签-loc"><a href="#根据标签-loc" class="headerlink" title="根据标签 loc"></a>根据标签 loc</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据行标签（loc第一个参数，只能用于行标签）</span></span><br><span class="line">print(df.loc[<span class="string">'20130102'</span>])</span><br><span class="line"><span class="comment"># print(df['20130102'])  这样是不可以的，会报错</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    4</span></span><br><span class="line"><span class="string">B    5</span></span><br><span class="line"><span class="string">C    6</span></span><br><span class="line"><span class="string">D    7</span></span><br><span class="line"><span class="string">Name: 2013-01-02 00:00:00, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment">#第二个参数筛选列名称</span></span><br><span class="line">print(df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]]) </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B</span></span><br><span class="line"><span class="string">2013-01-01   0   1</span></span><br><span class="line"><span class="string">2013-01-02   4   5</span></span><br><span class="line"><span class="string">2013-01-03   8   9</span></span><br><span class="line"><span class="string">2013-01-04  12  13</span></span><br><span class="line"><span class="string">2013-01-05  16  17</span></span><br><span class="line"><span class="string">2013-01-06  20  21</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="根据序列-iloc"><a href="#根据序列-iloc" class="headerlink" title="根据序列 iloc"></a>根据序列 iloc</h3><p>iloc第一个参数过滤行，第二个参数过滤列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             B   C</span></span><br><span class="line"><span class="string">2013-01-02   5   6</span></span><br><span class="line"><span class="string">2013-01-04  13  14</span></span><br><span class="line"><span class="string">2013-01-06  21  22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="根据混合的这两种-ix"><a href="#根据混合的这两种-ix" class="headerlink" title="根据混合的这两种 ix"></a>根据混合的这两种 ix</h3><p>前面我们知道，loc可以根据名称过滤，iloc可以根据index位置过滤，那结合这两种过滤方式可以用ix</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df.ix[:<span class="number">3</span>,[<span class="string">'A'</span>,<span class="string">'C'</span>]])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A   C</span></span><br><span class="line"><span class="string">2013-01-01  0   2</span></span><br><span class="line"><span class="string">2013-01-02  4   6</span></span><br><span class="line"><span class="string">2013-01-03  8  10</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p>设置值比较简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">2</span>,<span class="number">2</span>] = <span class="number">1111</span></span><br><span class="line">df.loc[<span class="string">'20130101'</span>,<span class="string">'B'</span>] = <span class="number">2222</span></span><br><span class="line">df.B[df.A&gt;<span class="number">4</span>] = <span class="number">0</span></span><br><span class="line">df[<span class="string">'F'</span>] = np.nan</span><br><span class="line"><span class="comment"># 插入一行</span></span><br><span class="line">df[<span class="string">'E'</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], index=pd.date_range(<span class="string">'20130101'</span>,periods=<span class="number">6</span>))</span><br></pre></td></tr></table></figure><h2 id="处理丢失数据"><a href="#处理丢失数据" class="headerlink" title="处理丢失数据"></a>处理丢失数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(</span><br><span class="line">    axis=<span class="number">0</span>,     <span class="comment"># 0: 对行进行操作; 1: 对列进行操作</span></span><br><span class="line">    how=<span class="string">'any'</span>   <span class="comment"># 'any': 只要存在 NaN 就 drop 掉; 'all': 必须全部是 NaN 才 drop </span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>fillna是将 NaN 的值用其他值代替, 比如代替成 0:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可以通过pd.isnull()判断是否有缺失数据 NaN, 为 True 表示缺失数据</p><p>下篇将总结下pandas的数据导入导出，数据合并等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用python进行科学计算，numpy和pandas这两个库是必不可少的。&lt;/p&gt;
&lt;p&gt;上一篇介绍了numpy，本篇介绍pandas&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="http://wangyeming.github.com/tags/python/"/>
    
      <category term="pandas" scheme="http://wangyeming.github.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础2--python科学计算之numpy</title>
    <link href="http://wangyeming.github.com/2018/09/04/machine-learning-base-numpy/"/>
    <id>http://wangyeming.github.com/2018/09/04/machine-learning-base-numpy/</id>
    <published>2018-09-04T05:55:18.000Z</published>
    <updated>2019-09-09T12:30:06.608Z</updated>
    
    <content type="html"><![CDATA[<p>利用python进行科学计算，numpy和pandas这两个库是必不可少的。</p><ul><li>运算速度快：numpy 和 pandas 都是采用 C 语言编写, pandas 又是基于 numpy, 是 numpy 的升级版本。</li><li>消耗资源少：采用的是矩阵运算，会比 python 自带的字典或者列表快好多</li></ul><p>先简单总结下numpy。</p><a id="more"></a><h2 id="numpy-导入"><a href="#numpy-导入" class="headerlink" title="numpy 导入"></a>numpy 导入</h2><p>省略下载和安装，代码中导入numpy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h2 id="numpy-array-创建"><a href="#numpy-array-创建" class="headerlink" title="numpy array 创建"></a>numpy array 创建</h2><p>numpy最常见的数据结构式array，创建一个numpy array也很简单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]])  <span class="comment"># python matrix</span></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int)</span><br><span class="line">a = np.zeros((<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 数据全为0，3行4列</span></span><br><span class="line">a = np.ones((<span class="number">3</span>, <span class="number">4</span>), dtype=np.int)  <span class="comment"># 数据为1，3行4列</span></span><br><span class="line">a = np.empty((<span class="number">3</span>, <span class="number">4</span>))  <span class="comment"># 数创建全空数组, 其实每个值都是接近于零的数</span></span><br><span class="line">a = np.arange(<span class="number">10</span>, <span class="number">20</span>, <span class="number">2</span>)  <span class="comment"># 10-19 的数据，2步长</span></span><br><span class="line">a = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))    <span class="comment"># 3行4列，0到11</span></span><br><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>)    <span class="comment"># 开始端1，结束端10，且分割成20个数据，生成线段</span></span><br></pre></td></tr></table></figure><h2 id="numpy-array的基本操作"><a href="#numpy-array的基本操作" class="headerlink" title="numpy array的基本操作"></a>numpy array的基本操作</h2><p>numpy的array有很多灵活的运算方法，包括单个array的四则运算，条件运算，变形, 转置, 对array任意一行一列进行求和,求最大最小值，求各类统计值等等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>])  <span class="comment"># array([10, 20, 30, 40])</span></span><br><span class="line">b = np.arange(<span class="number">4</span>)  <span class="comment"># array([0, 1, 2, 3])</span></span><br><span class="line">print(b ** <span class="number">2</span>)   <span class="comment"># 单个array每个元素乘方</span></span><br><span class="line">print(<span class="number">10</span> * np.sin(a))</span><br><span class="line">print(b &lt; <span class="number">3</span>)    <span class="comment"># 条件运算 [ True  True  True False]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵变形</span></span><br><span class="line">a = a.reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">b = b.reshape(<span class="number">2</span>, <span class="number">2</span>, )</span><br><span class="line"></span><br><span class="line">a = np.random.random((<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>)) <span class="comment">#生成随机矩阵</span></span><br><span class="line"></span><br><span class="line">print(np.sum(a))</span><br><span class="line">print(np.min(a))</span><br><span class="line">print(np.max(a))</span><br><span class="line">print(np.sort(a))</span><br><span class="line"></span><br><span class="line">print(np.transpose(a))</span><br><span class="line">print(a.T)      <span class="comment"># 矩阵转置</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])  <span class="comment"># array([10, 20, 30, 40])</span></span><br><span class="line">print(<span class="string">"sum ="</span>, np.sum(a, axis=<span class="number">0</span>))  <span class="comment"># 以列为单位,求和</span></span><br><span class="line">print(<span class="string">"sum ="</span>, np.sum(a, axis=<span class="number">1</span>))  <span class="comment"># 以行为单位，求和</span></span><br></pre></td></tr></table></figure><h3 id="两个array的加减乘"><a href="#两个array的加减乘" class="headerlink" title="两个array的加减乘"></a>两个array的加减乘</h3><p>当然也支持两个array相加，相减，相乘</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">print(a + b)            <span class="comment"># [5 4 3 2]</span></span><br><span class="line">print(a - b)            <span class="comment"># [[3 2 1 0]        </span></span><br><span class="line">print(a * b)            <span class="comment"># 矩阵相乘[4 3 2 1]</span></span><br><span class="line">print(np.dot(a, b))     <span class="comment"># 矩阵相乘求和 10</span></span><br><span class="line">print(np.multiply(a, b))<span class="comment"># 矩阵相乘 [16 12  8  4]</span></span><br></pre></td></tr></table></figure><p>也可以支持两个或者多个矩阵的合并和分割操作：</p><h3 id="array的合并"><a href="#array的合并" class="headerlink" title="array的合并"></a>array的合并</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># [[4 3 2 1]</span></span><br><span class="line"><span class="comment">#  [1 1 1 1]]</span></span><br><span class="line">print(np.vstack((A,B))) <span class="comment"># 垂直合并</span></span><br><span class="line"><span class="comment"># [4 3 2 1 1 1 1 1]</span></span><br><span class="line">print(np.hstack((a, b))) <span class="comment"># 水平合并</span></span><br><span class="line"><span class="comment"># [4 3 2 1 1 1 1 1 4 3 2 1]</span></span><br><span class="line">print(np.concatenate((a, b, a, axis=<span class="number">0</span>)) <span class="comment"># 多矩阵垂直合并</span></span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])[:, np.newaxis]</span><br><span class="line"><span class="comment">#[[4]</span></span><br><span class="line"><span class="comment"># [3]</span></span><br><span class="line"><span class="comment"># [2]</span></span><br><span class="line"><span class="comment"># [1]]</span></span><br><span class="line">b = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])[:, np.newaxis]</span><br><span class="line"><span class="comment">#[[1]</span></span><br><span class="line"><span class="comment"># [1]</span></span><br><span class="line"><span class="comment"># [1]</span></span><br><span class="line"><span class="comment"># [1]]</span></span><br><span class="line">print(np.concatenate((a, b, b), axis=<span class="number">1</span>)) <span class="comment"># 多矩阵水平合并</span></span><br><span class="line"><span class="comment">#[[4 1 1]</span></span><br><span class="line"><span class="comment"># [3 1 1]</span></span><br><span class="line"><span class="comment"># [2 1 1]</span></span><br><span class="line"><span class="comment"># [1 1 1]]</span></span><br></pre></td></tr></table></figure><h3 id="array的分割"><a href="#array的分割" class="headerlink" title="array的分割"></a>array的分割</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">    [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">    [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 纵向分割</span></span><br><span class="line">print(np.split(A, <span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 横向分割 </span></span><br><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">0</span>))</span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不等量的分割</span></span><br><span class="line">print(np.array_split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), array([[ 2],</span></span><br><span class="line"><span class="string">        [ 6],</span></span><br><span class="line"><span class="string">        [10]]), array([[ 3],</span></span><br><span class="line"><span class="string">        [ 7],</span></span><br><span class="line"><span class="string">        [11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h3 id="np-newaxis"><a href="#np-newaxis" class="headerlink" title="np.newaxis"></a>np.newaxis</h3><p>这里，我们使用了np.newaxis，newaxis的功能是插入新维度，结合例子我们看一下用法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(a)            <span class="comment"># [1 2 3 4]</span></span><br><span class="line">print(a.shape)      <span class="comment"># (4,)</span></span><br><span class="line"></span><br><span class="line">b = a[:, np.newaxis]</span><br><span class="line">print(b)            </span><br><span class="line"><span class="comment"># [[1]</span></span><br><span class="line"><span class="comment"># [2]</span></span><br><span class="line"><span class="comment"># [3]</span></span><br><span class="line"><span class="comment"># [4]] </span></span><br><span class="line">print(b.shape)      <span class="comment"># (4, 1)</span></span><br><span class="line"></span><br><span class="line">c = a[np.newaxis, :]</span><br><span class="line">print(c)            <span class="comment"># [[1 2 3 4]]</span></span><br><span class="line">print(c.shape)      <span class="comment"># (1, 4)</span></span><br></pre></td></tr></table></figure><p>总之numpy的array的操作方法很多，是我们科学计算的得力工具。</p><h2 id="numpy-copy-amp-deep-copy"><a href="#numpy-copy-amp-deep-copy" class="headerlink" title="numpy copy &amp; deep copy"></a>numpy copy &amp; deep copy</h2><p>numpy有两种方式拷贝值，一种是=号，一种是copy()方法，前者可以理解为引用，后者可以理解为简单的复制值。几行代码就明白了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">c = a.copy()</span><br><span class="line"></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span></span><br><span class="line">print(b)    <span class="comment"># [5 1 2 3]</span></span><br><span class="line">print(c)    <span class="comment"># [0 1 2 3]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用python进行科学计算，numpy和pandas这两个库是必不可少的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算速度快：numpy 和 pandas 都是采用 C 语言编写, pandas 又是基于 numpy, 是 numpy 的升级版本。&lt;/li&gt;
&lt;li&gt;消耗资源少：采用的是矩阵运算，会比 python 自带的字典或者列表快好多&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先简单总结下numpy。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习新手入门" scheme="http://wangyeming.github.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/"/>
    
    
      <category term="Machine Learning" scheme="http://wangyeming.github.com/tags/Machine-Learning/"/>
    
      <category term="python" scheme="http://wangyeming.github.com/tags/python/"/>
    
      <category term="numpy" scheme="http://wangyeming.github.com/tags/numpy/"/>
    
  </entry>
  
</feed>
